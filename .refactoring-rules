# üîß Refactoring Rules & Code Quality Standards
# Farmers Market Platform - Systematic Improvement Guidelines
# Created: December 26, 2024
# Purpose: Prevent new technical debt during refactoring process

# ============================================
# GENERAL PRINCIPLES
# ============================================

# 1. NO BREAKING CHANGES WITHOUT DEPRECATION PERIOD
#    - Use aliases when renaming exports
#    - Provide migration guides
#    - Give 2 weeks notice before removals

# 2. MAINTAIN OR IMPROVE TEST COVERAGE
#    - Current: 85% service coverage
#    - Target: Never decrease below 80%
#    - Add tests before refactoring

# 3. ONE CHANGE AT A TIME
#    - Small, focused commits
#    - Clear commit messages
#    - Easy to review and revert

# 4. DOCUMENT DECISIONS
#    - Update TECHNICAL_DEBT.md when fixing issues
#    - Update REFACTORING_PLAN.md with progress
#    - Add inline comments for complex changes

# ============================================
# NAMING CONVENTIONS
# ============================================

# ‚úÖ DO: Use Standard Business Terminology
createProduct()
updateProduct()
deleteProduct()
cache
repository
service
context

# ‚ùå DON'T: Use Metaphorical Names
manifestProduct()
quantumCache
divineRepository
agriculturalConsciousness

# ‚úÖ DO: Use Clear, Descriptive Names
getUserById()
calculateOrderTotal()
validatePaymentMethod()

# ‚ùå DON'T: Use Obscure Abbreviations
getUsrById()
calcOrdTot()
valPmtMthd()

# MIGRATION STRATEGY FOR EXISTING NAMES:
# 1. Create standard alias: export const cache = quantumCache;
# 2. Update internal usage gradually
# 3. Deprecate old name with warning
# 4. Remove after 1 month

# ============================================
# CONFIGURATION STANDARDS
# ============================================

# ‚úÖ DO: Use Environment Variables for Tuning
process.env.NODE_MAX_OLD_SPACE_SIZE || 8192
process.env.WEBPACK_PARALLELISM || os.cpus().length

# ‚ùå DON'T: Hardcode Hardware-Specific Values
parallelism: 12  // HP OMEN-specific
maxMemory: 64 * 1024  // 64GB RAM hardcoded

# ‚úÖ DO: Detect Capabilities at Runtime
const availableMemory = os.freemem();
const cpuCount = os.cpus().length;

# ‚ùå DON'T: Reference Specific Hardware
// HP OMEN ULTIMATE OPTIMIZATION
// RTX 2070 MAX-Q 8GB

# ‚úÖ DO: Keep Configurations Simple
// Max 250 lines per config file
// Extract complex logic to separate modules

# ‚ùå DON'T: Create Monolithic Config Files
// 500+ line next.config.mjs

# ============================================
# TYPESCRIPT STANDARDS
# ============================================

# ‚úÖ DO: Enable Strict Type Checking
typescript: {
  ignoreBuildErrors: false,
  strict: true
}

# ‚ùå DON'T: Suppress Errors Without Investigation
typescript: {
  ignoreBuildErrors: true,  // ‚ùå Bad practice
}

# ‚úÖ DO: Fix Root Causes
// Investigate why errors occur
// Fix the actual issue
// Document if workaround needed

# ‚ùå DON'T: Add @ts-ignore Everywhere
// @ts-ignore
const foo = bar;  // ‚ùå Hiding problems

# ‚úÖ DO: Use Proper Types
interface CreateProductDTO {
  name: string;
  price: number;
}

# ‚ùå DON'T: Use any Unless Truly Necessary
function createProduct(data: any) { }  // ‚ùå

# ============================================
# CODE ORGANIZATION
# ============================================

# ‚úÖ DO: Group Related Code
src/lib/payment/
  ‚îú‚îÄ‚îÄ stripe.ts
  ‚îú‚îÄ‚îÄ paypal.ts
  ‚îî‚îÄ‚îÄ index.ts

# ‚ùå DON'T: Scatter Related Code
src/lib/payment/
src/lib/payments/
src/lib/stripe/

# ‚úÖ DO: Use 2-3 Layer Architecture Maximum
API Route ‚Üí Service ‚Üí Repository ‚Üí Database

# ‚ùå DON'T: Create Unnecessary Layers
API Route ‚Üí Controller ‚Üí Service ‚Üí Repository ‚Üí Database
(Controller is often redundant)

# ‚úÖ DO: Keep Modules Focused
src/lib/monitoring/  (telemetry + tracing + logging)

# ‚ùå DON'T: Fragment Related Functionality
src/lib/monitoring/
src/lib/telemetry/
src/lib/tracing/

# TARGET: Reduce src/lib from 32 to ~20 focused modules

# ============================================
# DEPENDENCY MANAGEMENT
# ============================================

# ‚úÖ DO: Keep Dependencies Updated
npm audit
npm outdated
npm update

# ‚ùå DON'T: Ignore Security Warnings
6 vulnerabilities (critical) ‚Üê Fix these!

# ‚úÖ DO: Remove Unused Dependencies
npm prune
npx depcheck

# ‚ùå DON'T: Install Without Purpose
npm install cool-package  // "might need it later"

# ‚úÖ DO: Use Development Dependencies Correctly
devDependencies: testing, building, documentation
dependencies: production runtime

# ‚ùå DON'T: Put Everything in dependencies

# ============================================
# TESTING STANDARDS
# ============================================

# ‚úÖ DO: Write Tests Before Refactoring
// Establish baseline behavior
// Refactor with confidence
// Verify nothing broke

# ‚ùå DON'T: Refactor Without Test Coverage
// "It works on my machine"
// No way to verify correctness

# ‚úÖ DO: Maintain Test Quality
// Clear test names
// Arrange-Act-Assert pattern
// Test behavior, not implementation

# ‚ùå DON'T: Write Brittle Tests
// Testing internal implementation details
// Breaks on every refactor

# TARGET COVERAGE:
# - Overall: 60%+ (current: 58%)
# - Service Layer: 85%+ (current: 85% ‚úÖ)
# - Critical Paths: 100%

# ============================================
# DOCUMENTATION STANDARDS
# ============================================

# ‚úÖ DO: Update Docs With Code Changes
// Update README when features change
// Update API docs when endpoints change
// Update architecture docs when structure changes

# ‚ùå DON'T: Let Documentation Drift
// Outdated examples
// Wrong API signatures
// Non-existent features documented

# ‚úÖ DO: Keep Documentation Consolidated
README.md
ARCHITECTURE.md
DEPLOYMENT.md
CONTRIBUTING.md

# ‚ùå DON'T: Create Redundant Docs
README.md
README2.md
README_FINAL.md
README_FINAL_FINAL.md

# ‚úÖ DO: Use Version Control for History
// Git history shows evolution
// No need for "OLD_README.md"

# ‚ùå DON'T: Keep Outdated Files
DEPLOYMENT_OLD.md
ARCHITECTURE_v1.md
ARCHITECTURE_v2.md

# ============================================
# PERFORMANCE CONSIDERATIONS
# ============================================

# ‚úÖ DO: Measure Before Optimizing
// Benchmark current performance
// Make change
// Verify improvement

# ‚ùå DON'T: Optimize Prematurely
// "This might be slow"
// Adds complexity without benefit

# ‚úÖ DO: Keep Optimizations Maintainable
// Simple, understandable code
// Comments explaining why

# ‚ùå DON'T: Sacrifice Readability
// Clever one-liners
// Micro-optimizations
// Hard to understand logic

# DURING REFACTORING:
# - Build time should stay the same or improve
# - Test time should stay the same or improve
# - Bundle size should stay the same or decrease

# ============================================
# GIT WORKFLOW
# ============================================

# ‚úÖ DO: Use Feature Branches
git checkout -b refactor/phase-1-typescript-fixes
git checkout -b refactor/simplify-naming
git checkout -b refactor/consolidate-payment-modules

# ‚ùå DON'T: Work Directly on Main
git checkout main
git commit -am "changed everything"  // ‚ùå

# ‚úÖ DO: Write Clear Commit Messages
refactor: remove ignoreBuildErrors from next.config.mjs

TypeScript compilation verified clean with `npx tsc --noEmit`.
Safe to enable strict type checking.

Closes CRIT-001 in TECHNICAL_DEBT.md

# ‚ùå DON'T: Write Vague Messages
git commit -am "fixes"
git commit -am "updates"
git commit -am "stuff"

# COMMIT MESSAGE FORMAT:
# <type>: <subject>
#
# <body>
#
# <footer>

# Types: refactor, fix, feat, docs, test, chore

# ============================================
# CODE REVIEW CHECKLIST
# ============================================

# Before submitting PR, verify:
[ ] All tests passing (npm test)
[ ] TypeScript compiles (npx tsc --noEmit)
[ ] Linting passes (npm run lint)
[ ] Build succeeds (npm run build)
[ ] No new console.log() in production code
[ ] No new TODO without ticket reference
[ ] Documentation updated if needed
[ ] TECHNICAL_DEBT.md updated if fixing debt
[ ] No hardcoded credentials or secrets
[ ] No hardware-specific code added
[ ] Follows naming conventions
[ ] Test coverage maintained or improved

# ============================================
# REFACTORING ANTI-PATTERNS TO AVOID
# ============================================

# ‚ùå Big Bang Refactoring
# - Changing everything at once
# - High risk of breaking things
# - Hard to review
# INSTEAD: Small, incremental changes

# ‚ùå Premature Abstraction
# - Creating layers "we might need"
# - Over-engineering solutions
# INSTEAD: Abstract when you have 3+ similar cases

# ‚ùå Analysis Paralysis
# - Endless planning without action
# - Perfect solution syndrome
# INSTEAD: Start with small wins, iterate

# ‚ùå Scope Creep
# - "While I'm here, let me also..."
# - Mixing multiple concerns
# INSTEAD: One focused change per PR

# ‚ùå Breaking Changes Without Warning
# - Removing APIs immediately
# - No migration path
# INSTEAD: Deprecate ‚Üí Warn ‚Üí Remove (gradual)

# ============================================
# EMERGENCY ROLLBACK PROCEDURE
# ============================================

# If refactoring causes issues:

# 1. Identify the problematic commit
git log --oneline

# 2. Create hotfix branch
git checkout -b hotfix/rollback-refactor-issue

# 3. Revert the commit
git revert <commit-hash>

# 4. Or reset to previous state
git reset --hard <good-commit-hash>

# 5. Test thoroughly
npm test
npm run build

# 6. Deploy fixed version

# 7. Document what went wrong
# Update TECHNICAL_DEBT.md with lessons learned

# ============================================
# AUTOMATION & TOOLING
# ============================================

# Use these tools to enforce standards:

# Pre-commit hooks (Husky):
- npm run type-check
- npm run lint
- npm test (fast tests only)

# CI/CD checks:
- Full test suite
- Build verification
- Bundle size analysis
- Performance regression testing

# Recommended tools:
- ESLint: Code quality
- Prettier: Code formatting
- depcheck: Unused dependencies
- madge: Circular dependencies
- jscpd: Code duplication detection

# ============================================
# METRICS TO TRACK
# ============================================

# Before & After Each Phase:
- Build time (target: < 30 seconds)
- Test time (target: < 5 minutes)
- Bundle size (target: no increase)
- Test coverage (target: ‚â• 85% services)
- TypeScript errors (target: 0)
- ESLint warnings (target: < 10)
- Security vulnerabilities (target: 0 critical)
- File count in src/lib (target: 20 modules)
- Lines in next.config.mjs (target: < 250)

# ============================================
# SUCCESS CRITERIA
# ============================================

# Refactoring is successful when:
‚úÖ All tests still passing
‚úÖ No functionality lost
‚úÖ Code is more maintainable
‚úÖ New developers can understand code faster
‚úÖ Documentation is up to date
‚úÖ Performance is same or better
‚úÖ Security is same or better
‚úÖ Team velocity maintained or improved

# ============================================
# QUESTIONS TO ASK BEFORE EACH CHANGE
# ============================================

1. Does this fix actual technical debt?
2. Is this the simplest solution?
3. Can I test this change?
4. Will this break existing code?
5. Do I need to deprecate something first?
6. Is documentation needed?
7. What's the rollback plan?
8. Have I measured the impact?

# ============================================
# WHEN TO STOP REFACTORING
# ============================================

Stop when:
- Core technical debt is resolved
- Code is "good enough" (not perfect)
- Team is comfortable with changes
- Business needs new features
- Risk outweighs benefit

Remember: "Perfect is the enemy of good"

# ============================================
# END OF REFACTORING RULES
# ============================================

# Last Updated: December 26, 2024
# Next Review: January 9, 2025 (End of Phase 1)
# Status: ACTIVE

# üåæ "Improve systematically, one step at a time"
