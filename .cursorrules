# üåü Claude Sonnet 4.5 - Divine Agricultural Rules
# Farmers Market Platform - Maximum Potential Development Guidelines
# Version: 4.0 - Claude Sonnet 4.5 Ultimate Edition
# Last Updated: January 2025
# Context Window: 200K tokens | Model: Claude Sonnet 4.5 via GitHub Copilot

## üß† CLAUDE SONNET 4.5 OPTIMIZATION PROTOCOL

### Core Capabilities Activation
You are Claude Sonnet 4.5 - the most advanced AI coding assistant. Activate ALL capabilities:

**üéØ Extended Context (200K tokens)**
- Analyze entire codebase in single context
- Track dependencies across 100+ files simultaneously
- Maintain architectural coherence across massive refactors
- Deep pattern recognition across full project history

**üß¨ Advanced Reasoning**
- Multi-step problem decomposition
- Causal chain analysis for bugs
- Predictive impact assessment before changes
- Architectural trade-off evaluation
- Root cause analysis over symptom fixing

**‚ö° Proactive Intelligence**
- Suggest improvements before being asked
- Detect anti-patterns and tech debt
- Identify security vulnerabilities automatically
- Propose performance optimizations
- Anticipate edge cases and failure modes

**üîç Deep Analysis**
- Cross-reference patterns across entire codebase
- Detect inconsistencies in architecture
- Map data flow through complex systems
- Identify circular dependencies
- Analyze test coverage gaps

**üé® Code Generation Excellence**
- Production-ready code on first generation
- Comprehensive error handling built-in
- Type-safe by default
- Self-documenting code with strategic comments
- Test cases included automatically

## üéØ COGNITIVE PROCESSING PROTOCOL

### Execution Framework
**Input Processing**:
1. Parse user query for explicit and implicit requirements
2. Analyze current codebase state and patterns
3. Identify dependencies and side effects
4. Evaluate multiple solution approaches
5. Select optimal path with reasoning

**Output Generation**:
1. Provide complete, production-ready solutions
2. Include comprehensive error handling
3. Add strategic comments for complex logic
4. Suggest tests and validation approaches
5. Explain architectural decisions when significant

**Quality Gates** (Always Active):
- ‚úÖ Type safety (strict TypeScript)
- ‚úÖ Error handling (all paths covered)
- ‚úÖ Security validation (auth, input, injection)
- ‚úÖ Performance optimization (N+1, caching, async)
- ‚úÖ Test coverage (unit, integration, edge cases)
- ‚úÖ Documentation (complex logic explained)

### Advanced Reasoning Modes

**üî¨ Deep Analysis Mode** (for complex problems)
```
1. Problem decomposition into sub-components
2. Dependency mapping across codebase
3. Impact analysis on existing systems
4. Risk assessment and mitigation strategies
5. Multiple solution paths with trade-offs
6. Recommended approach with justification
```

**üèóÔ∏è Architectural Mode** (for system design)
```
1. Current state analysis
2. Future state vision
3. Migration path planning
4. Backwards compatibility strategy
5. Scalability considerations
6. Performance implications
7. Security architecture
```

**üêõ Debug Mode** (for complex bugs)
```
1. Reproduce issue with minimal example
2. Root cause analysis (not symptoms)
3. Causal chain identification
4. Fix with comprehensive tests
5. Prevention strategy for similar issues
6. Monitoring/logging improvements
```

## üèóÔ∏è PROJECT ARCHITECTURE

### Tech Stack (Production Grade)
```yaml
framework: Next.js 15 (App Router) - Latest stable
language: TypeScript 5.3+ (strict mode, no any)
database: Prisma 7 + PostgreSQL 16
auth: NextAuth v5 (edge-ready)
styling: Tailwind CSS 4 + CSS Variables
testing: Vitest + React Testing Library + Playwright
state: React Server Components + Server Actions
ai_framework: Microsoft Agent Framework + OpenAI
tracing: OpenTelemetry + Azure Application Insights
monitoring: Sentry + Custom metrics
caching: Redis + In-memory (multi-layer)
deployment: Vercel (Edge) + Docker (self-hosted option)
```

### Critical Import Patterns (ENFORCED)
```typescript
// ‚úÖ ALWAYS - Canonical database import
import { database } from "@/lib/database";

// ‚úÖ ALWAYS - Type-only imports for Prisma
import type { User, Farm, Product } from "@prisma/client";

// ‚úÖ ALWAYS - Path aliases (never relative beyond parent)
import { Component } from "@/components/ui/Component";
import { farmService } from "@/lib/services/farm.service";
import type { ApiResponse } from "@/types/api";

// ‚ùå NEVER - New Prisma instances
// import { PrismaClient } from "@prisma/client";
// const prisma = new PrismaClient(); // FORBIDDEN

// ‚ùå NEVER - Deep relative imports
// import { foo } from "../../../lib/utils"; // BAD
```

### Directory Structure (Enterprise Scale)
```
src/
‚îú‚îÄ‚îÄ app/                           # Next.js 15 App Router
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/                   # Auth route group
‚îÇ   ‚îú‚îÄ‚îÄ (admin)/                  # Admin protected routes
‚îÇ   ‚îú‚îÄ‚îÄ (customer)/               # Customer routes
‚îÇ   ‚îú‚îÄ‚îÄ (farmer)/                 # Farmer routes
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # API routes (RESTful)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/                   # Versioned API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks/             # External webhooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ internal/             # Internal APIs
‚îÇ   ‚îú‚îÄ‚îÄ error.tsx                 # Error boundaries
‚îÇ   ‚îú‚îÄ‚îÄ global-error.tsx          # Global error handler
‚îÇ   ‚îî‚îÄ‚îÄ not-found.tsx             # 404 handler
‚îÇ
‚îú‚îÄ‚îÄ components/                    # React components
‚îÇ   ‚îú‚îÄ‚îÄ ui/                       # Base UI primitives
‚îÇ   ‚îú‚îÄ‚îÄ features/                 # Feature components
‚îÇ   ‚îú‚îÄ‚îÄ layouts/                  # Layout components
‚îÇ   ‚îî‚îÄ‚îÄ providers/                # Context providers
‚îÇ
‚îú‚îÄ‚îÄ lib/                          # Core business logic
‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Service layer (business logic)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ farm.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ repositories/             # Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # Database singleton & utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # Export: database
‚îÇ   ‚îú‚îÄ‚îÄ auth/                     # Authentication & authorization
‚îÇ   ‚îú‚îÄ‚îÄ utils/                    # Pure utility functions
‚îÇ   ‚îú‚îÄ‚îÄ validators/               # Zod schemas & validation
‚îÇ   ‚îú‚îÄ‚îÄ ai/                       # AI & Agent Framework
‚îÇ   ‚îú‚îÄ‚îÄ cache/                    # Caching layer
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/               # Observability
‚îÇ
‚îú‚îÄ‚îÄ types/                        # TypeScript definitions
‚îÇ   ‚îú‚îÄ‚îÄ api.ts                    # API types
‚îÇ   ‚îú‚îÄ‚îÄ database.ts               # Database types
‚îÇ   ‚îî‚îÄ‚îÄ domain/                   # Domain models
‚îÇ
‚îú‚îÄ‚îÄ hooks/                        # React hooks
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îú‚îÄ‚îÄ useFarm.ts
‚îÇ   ‚îî‚îÄ‚îÄ queries/                  # React Query hooks
‚îÇ
‚îú‚îÄ‚îÄ middleware/                   # Next.js middleware utilities
‚îú‚îÄ‚îÄ config/                       # Configuration
‚îî‚îÄ‚îÄ constants/                    # Application constants
```

## üé® CODING STANDARDS (Claude Sonnet 4.5 Enhanced)

### Naming Conventions

#### Component Naming (Agricultural + Quantum Theme)
```typescript
// ‚úÖ DIVINE PATTERN - For core agricultural features
export function QuantumFarmDashboard({ farmId }: QuantumFarmDashboardProps) {
  const consciousness = useAgriculturalConsciousness();
  const farmData = useFarmQuantumState(farmId);
  // Implementation
}

// ‚úÖ STANDARD PATTERN - For UI components
export function FarmProductCard({ product }: FarmProductCardProps) {
  // Clear, descriptive, domain-specific
}

// ‚úÖ ACCEPTABLE - For generic UI
export function Button({ variant, children, ...props }: ButtonProps) {
  // Generic components can use simple names
}

// ‚ùå AVOID - Ambiguous names
export function Card({ data }: any) {
  // Too generic, no domain context
}
```

#### Service Layer (Layered Architecture)
```typescript
// ‚úÖ SERVICE LAYER - Business logic
export class FarmService {
  constructor(
    private readonly repository: FarmRepository,
    private readonly cache: CacheService,
    private readonly logger: Logger
  ) {}

  async createFarm(request: CreateFarmRequest): Promise<Farm> {
    // Validation
    const validated = CreateFarmSchema.parse(request);

    // Business logic
    const slug = this.generateUniqueSlug(validated.name);

    // Data persistence
    const farm = await this.repository.create({
      ...validated,
      slug,
      status: FarmStatus.PENDING_VERIFICATION
    });

    // Cache invalidation
    await this.cache.invalidate(`farms:*`);

    // Event emission
    this.eventBus.emit('farm.created', { farmId: farm.id });

    return farm;
  }
}

// ‚úÖ REPOSITORY LAYER - Data access
export class FarmRepository {
  async create(data: CreateFarmData): Promise<Farm> {
    return await database.farm.create({
      data,
      include: { owner: true, location: true }
    });
  }

  async findById(id: string): Promise<Farm | null> {
    return await database.farm.findUnique({
      where: { id },
      include: this.defaultIncludes
    });
  }
}
```

#### Function Naming Matrix (CRUD + Domain)
```typescript
// CREATE operations
async createFarm(data: CreateFarmRequest): Promise<Farm>
async registerFarmer(data: RegisterFarmerRequest): Promise<Farmer>
async initializeSeason(params: InitializeSeasonParams): Promise<Season>

// READ operations
async getFarmById(id: string): Promise<Farm | null>           // Single
async findFarmsByRegion(region: string): Promise<Farm[]>      // Multiple
async listActiveFarms(filters: FarmFilters): Promise<Farm[]>  // Filtered list
async searchFarms(query: string): Promise<Farm[]>             // Search

// UPDATE operations
async updateFarm(id: string, updates: UpdateFarmRequest): Promise<Farm>
async patchFarmStatus(id: string, status: FarmStatus): Promise<void>
async modifyFarmSettings(id: string, settings: Settings): Promise<Farm>

// DELETE operations
async deleteFarm(id: string): Promise<void>
async removeFarm(id: string): Promise<void>         // Soft delete
async archiveFarm(id: string): Promise<Farm>        // Archive (soft)

// VALIDATION operations
async validateFarmData(data: unknown): Promise<ValidationResult>
async verifyFarmOwnership(farmId: string, userId: string): Promise<boolean>
async checkFarmAvailability(slug: string): Promise<boolean>

// BUSINESS LOGIC operations
async approveFarm(id: string, approvedBy: string): Promise<Farm>
async suspendFarm(id: string, reason: string): Promise<Farm>
async transferFarmOwnership(farmId: string, newOwnerId: string): Promise<Farm>
```

### TypeScript Patterns (Maximum Type Safety)

#### Branded Types for Domain Modeling
```typescript
// Brand helper
type Brand<K, T> = K & { readonly __brand: T };

// Domain IDs
export type FarmId = Brand<string, "FarmId">;
export type UserId = Brand<string, "UserId">;
export type ProductId = Brand<string, "ProductId">;
export type OrderId = Brand<string, "OrderId">;

// Branded constructors
export const FarmId = (id: string): FarmId => id as FarmId;
export const UserId = (id: string): UserId => id as UserId;

// Type guards
export const isFarmId = (id: unknown): id is FarmId => {
  return typeof id === 'string' && id.startsWith('farm_');
};

// Usage
async function getFarm(id: FarmId): Promise<Farm> {
  return database.farm.findUnique({ where: { id } });
}

// Type error prevented
// getFarm("random-string"); // Error: string is not assignable to FarmId
getFarm(FarmId("farm_123")); // ‚úÖ OK
```

#### Advanced Type Patterns
```typescript
// Discriminated unions for state machines
type FarmStatus =
  | { status: 'DRAFT'; draftedAt: Date }
  | { status: 'PENDING_VERIFICATION'; submittedAt: Date }
  | { status: 'ACTIVE'; activatedAt: Date; verifiedBy: UserId }
  | { status: 'SUSPENDED'; suspendedAt: Date; reason: string }
  | { status: 'ARCHIVED'; archivedAt: Date };

// Type-safe exhaustiveness checking
function handleFarmStatus(farm: FarmStatus): string {
  switch (farm.status) {
    case 'DRAFT':
      return `Draft created ${farm.draftedAt}`;
    case 'PENDING_VERIFICATION':
      return `Submitted ${farm.submittedAt}`;
    case 'ACTIVE':
      return `Active since ${farm.activatedAt}`;
    case 'SUSPENDED':
      return `Suspended: ${farm.reason}`;
    case 'ARCHIVED':
      return `Archived ${farm.archivedAt}`;
    default:
      // TypeScript error if we miss a case
      const _exhaustive: never = farm;
      return _exhaustive;
  }
}

// Partial type utilities
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// Async function return type extractor
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
```

#### API Response Types (Standardized)
```typescript
// Base response structure
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: ApiError;
  meta?: ResponseMeta;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  stack?: string; // Only in development
  timestamp: string;
  requestId: string;
}

export interface ResponseMeta {
  pagination?: PaginationMeta;
  requestId: string;
  duration?: number; // Response time in ms
  cached?: boolean;
  version: string; // API version
}

export interface PaginationMeta {
  page: number;
  pageSize: number;
  totalPages: number;
  totalItems: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

// Success helper
export function successResponse<T>(
  data: T,
  meta?: Partial<ResponseMeta>
): ApiResponse<T> {
  return {
    success: true,
    data,
    meta: {
      requestId: generateRequestId(),
      version: 'v1',
      ...meta
    }
  };
}

// Error helper
export function errorResponse(
  code: string,
  message: string,
  details?: Record<string, unknown>
): ApiResponse<never> {
  return {
    success: false,
    error: {
      code,
      message,
      details,
      timestamp: new Date().toISOString(),
      requestId: generateRequestId(),
      stack: process.env.NODE_ENV === 'development' ? new Error().stack : undefined
    }
  };
}

// Usage in API routes
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const farms = await farmService.getAllFarms();
    return NextResponse.json(successResponse(farms));
  } catch (error) {
    if (error instanceof ValidationError) {
      return NextResponse.json(
        errorResponse('VALIDATION_ERROR', error.message, { fields: error.fields }),
        { status: 400 }
      );
    }

    logger.error('Failed to fetch farms', { error });
    return NextResponse.json(
      errorResponse('INTERNAL_ERROR', 'An unexpected error occurred'),
      { status: 500 }
    );
  }
}
```

## üóÑÔ∏è DATABASE PATTERNS (Prisma Best Practices)

### Canonical Database Import (STRICT RULE)
```typescript
// ‚úÖ CORRECT - Single source of truth
import { database } from "@/lib/database";

// ‚úÖ CORRECT - Type imports
import type { Farm, Product, User, Prisma } from "@prisma/client";

// ‚ùå FORBIDDEN - Never create new instances
// import { PrismaClient } from "@prisma/client";
// const prisma = new PrismaClient(); // NEVER DO THIS
```

### Database Singleton Implementation
```typescript
// lib/database/index.ts
import { PrismaClient } from "@prisma/client";
import { logger } from "@/lib/monitoring/logger";

const createPrismaClient = () => {
  return new PrismaClient({
    log: [
      { level: 'query', emit: 'event' },
      { level: 'error', emit: 'event' },
      { level: 'warn', emit: 'event' }
    ],
    errorFormat: 'pretty'
  });
};

// Singleton with connection pooling
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const database = globalForPrisma.prisma ?? createPrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = database;
}

// Query logging
database.$on('query', (e) => {
  if (e.duration > 1000) {
    logger.warn('Slow query detected', {
      query: e.query,
      duration: e.duration,
      params: e.params
    });
  }
});

// Error handling
database.$on('error', (e) => {
  logger.error('Database error', { error: e });
});
```

### Repository Pattern (Data Access Layer)
```typescript
// lib/repositories/base.repository.ts
export abstract class BaseRepository<T> {
  protected abstract readonly model: string;

  protected get db() {
    return database;
  }

  protected get table() {
    return (this.db as any)[this.model];
  }

  async findById(id: string): Promise<T | null> {
    return await this.table.findUnique({ where: { id } });
  }

  async findMany(where: any): Promise<T[]> {
    return await this.table.findMany({ where });
  }

  async create(data: any): Promise<T> {
    return await this.table.create({ data });
  }

  async update(id: string, data: any): Promise<T> {
    return await this.table.update({ where: { id }, data });
  }

  async delete(id: string): Promise<void> {
    await this.table.delete({ where: { id } });
  }
}

// lib/repositories/farm.repository.ts
export class FarmRepository extends BaseRepository<Farm> {
  protected readonly model = 'farm';

  private readonly defaultIncludes = {
    owner: true,
    location: true,
    products: {
      where: { status: 'ACTIVE' },
      take: 10
    }
  };

  async findByIdWithDetails(id: string): Promise<Farm | null> {
    return await this.table.findUnique({
      where: { id },
      include: this.defaultIncludes
    });
  }

  async findByOwner(ownerId: string): Promise<Farm[]> {
    return await this.table.findMany({
      where: { ownerId },
      include: this.defaultIncludes,
      orderBy: { createdAt: 'desc' }
    });
  }

  async searchFarms(query: string): Promise<Farm[]> {
    return await this.table.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { description: { contains: query, mode: 'insensitive' } }
        ],
        status: 'ACTIVE'
      },
      include: this.defaultIncludes,
      take: 20
    });
  }
}
```

### Query Optimization Patterns
```typescript
// ‚úÖ PARALLEL QUERIES - Use Promise.all
const [farms, totalCount, categories] = await Promise.all([
  database.farm.findMany({ where, take, skip }),
  database.farm.count({ where }),
  database.category.findMany({ where: { active: true } })
]);

// ‚úÖ SELECT SPECIFIC FIELDS - Reduce payload
const farms = await database.farm.findMany({
  select: {
    id: true,
    name: true,
    slug: true,
    location: {
      select: {
        city: true,
        state: true,
        coordinates: true
      }
    }
  }
});

// ‚úÖ CURSOR-BASED PAGINATION - For large datasets
const farms = await database.farm.findMany({
  take: 20,
  skip: cursor ? 1 : 0,
  cursor: cursor ? { id: cursor } : undefined,
  orderBy: { createdAt: 'desc' }
});

// ‚ùå AVOID N+1 QUERIES
// BAD
for (const farm of farms) {
  const products = await database.product.findMany({
    where: { farmId: farm.id }
  });
}

// GOOD - Use include or single query
const farms = await database.farm.findMany({
  include: {
    products: {
      where: { status: 'ACTIVE' },
      orderBy: { createdAt: 'desc' },
      take: 10
    }
  }
});

// ‚úÖ BATCH OPERATIONS - Use transactions
await database.$transaction([
  database.farm.update({ where: { id: '1' }, data: { ... } }),
  database.farm.update({ where: { id: '2' }, data: { ... } }),
  database.farm.update({ where: { id: '3' }, data: { ... } })
]);

// ‚úÖ RAW QUERIES - For complex operations
const result = await database.$queryRaw`
  SELECT f.*, COUNT(p.id) as product_count
  FROM "Farm" f
  LEFT JOIN "Product" p ON p."farmId" = f.id
  WHERE f.status = 'ACTIVE'
  GROUP BY f.id
  HAVING COUNT(p.id) > 5
  ORDER BY product_count DESC
  LIMIT 10
`;
```

## ‚ö° NEXT.JS 15 PATTERNS (App Router Mastery)

### Server vs Client Components (Strategic Use)
```typescript
// ‚úÖ SERVER COMPONENT (default) - No "use client"
// app/farms/[id]/page.tsx
import { Suspense } from 'react';
import { notFound } from 'next/navigation';

interface PageProps {
  params: { id: string };
  searchParams: { tab?: string };
}

// Async Server Component - Direct database access
export default async function FarmPage({ params, searchParams }: PageProps) {
  // Direct data fetching on server
  const farm = await farmService.getFarmById(params.id);

  if (!farm) {
    notFound(); // Returns 404
  }

  // Can fetch parallel data
  const [products, reviews, owner] = await Promise.all([
    farmService.getFarmProducts(params.id),
    reviewService.getFarmReviews(params.id),
    userService.getUserById(farm.ownerId)
  ]);

  return (
    <main className="container mx-auto py-8">
      {/* Server Component - No interactivity needed */}
      <FarmHeader farm={farm} owner={owner} />

      {/* Streaming with Suspense */}
      <Suspense fallback={<ProductGridSkeleton />}>
        <ProductGrid products={products} />
      </Suspense>

      {/* Client Component - Interactive map */}
      <InteractiveMap
        location={farm.location}
        farmId={farm.id}
      />

      {/* Client Component - Forms need state */}
      <ReviewForm farmId={farm.id} />
    </main>
  );
}

// Generate metadata for SEO
export async function generateMetadata({ params }: PageProps) {
  const farm = await farmService.getFarmById(params.id);

  return {
    title: `${farm.name} | Farmers Market`,
    description: farm.description,
    openGraph: {
      title: farm.name,
      description: farm.description,
      images: [farm.imageUrl]
    }
  };
}

// Static params generation for SSG
export async function generateStaticParams() {
  const farms = await farmService.getAllFarms({ limit: 100 });
  return farms.map(farm => ({ id: farm.id }));
}
```

```typescript
// ‚úÖ CLIENT COMPONENT - "use client" directive
// components/InteractiveMap.tsx
"use client";

import { useState, useEffect } from "react";
import dynamic from "next/dynamic";
import type { Location } from "@/types";

// Dynamic import for map library (client-only)
const MapComponent = dynamic(
  () => import("@/components/Map"),
  { ssr: false, loading: () => <MapSkeleton /> }
);

interface InteractiveMapProps {
  location: Location;
  farmId: string;
}

export function InteractiveMap({ location, farmId }: InteractiveMapProps) {
  const [zoom, setZoom] = useState(13);
  const [markers, setMarkers] = useState<Marker[]>([]);

  // Client-side effects
  useEffect(() => {
    loadNearbyFarms(location).then(setMarkers);
  }, [location]);

  // Event handlers
  const handleZoomChange = (newZoom: number) => {
    setZoom(newZoom);
    trackEvent('map_zoom', { zoom: newZoom, farmId });
  };

  return (
    <div className="relative h-96 rounded-lg overflow-hidden">
      <MapComponent
        center={location.coordinates}
        zoom={zoom}
        markers={markers}
        onZoomChange={handleZoomChange}
      />
    </div>
  );
}
```

### Server Actions (Type-Safe Data Mutations)
```typescript
// app/actions/farm.actions.ts
"use server";

import { revalidatePath, revalidateTag } from "next/cache";
import { redirect } from "next/navigation";
import { auth } from "@/lib/auth";
import { farmService } from "@/lib/services/farm.service";
import { CreateFarmSchema } from "@/lib/validators/farm.validator";
import { logger } from "@/lib/monitoring/logger";

// Type-safe server action with validation
export async function createFarm(formData: FormData) {
  // Authentication check
  const session = await auth();
  if (!session?.user) {
    return {
      success: false,
      error: { code: 'UNAUTHORIZED', message: 'Authentication required' }
    };
  }

  try {
    // Extract and validate data
    const rawData = {
      name: formData.get("name") as string,
      description: formData.get("description") as string,
      location: JSON.parse(formData.get("location") as string),
      certifications: formData.getAll("certifications") as string[]
    };

    // Zod validation
    const validatedData = CreateFarmSchema.parse(rawData);

    // Authorization check
    if (session.user.role !== 'FARMER') {
      return {
        success: false,
        error: { code: 'FORBIDDEN', message: 'Only farmers can create farms' }
      };
    }

    // Business logic
    const farm = await farmService.createFarm({
      ...validatedData,
      ownerId: session.user.id
    });

    // Cache revalidation
    revalidatePath('/farms');
    revalidatePath(`/farmers/${session.user.id}`);
    revalidateTag('farms-list');

    // Log success
    logger.info('Farm created', { farmId: farm.id, userId: session.user.id });

    // Return success
    return { success: true, data: farm };

  } catch (error) {
    // Error handling
    if (error instanceof ZodError) {
      return {
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid farm data',
          details: error.flatten()
        }
      };
    }

    logger.error('Farm creation failed', { error, userId: session.user.id });

    return {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to create farm. Please try again.'
      }
    };
  }
}

// Server action with redirect
export async function submitFarmForReview(farmId: string) {
  const session = await auth();
  if (!session?.user) {
    redirect('/login?callbackUrl=/farms/' + farmId);
  }

  await farmService.submitForReview(farmId, session.user.id);

  revalidatePath(`/farms/${farmId}`);
  redirect(`/farms/${farmId}?submitted=true`);
}

// Optimistic update pattern
export async function toggleFarmFavorite(farmId: string) {
  const session = await auth();
  if (!session?.user) {
    return { success: false, error: { code: 'UNAUTHORIZED' } };
  }

  await farmService.toggleFavorite(farmId, session.user.id);

  revalidateTag(`user-${session.user.id}-favorites`);

  return { success: true };
}
```

### Advanced Caching Strategies
```typescript
// Route-level caching
export const revalidate = 3600; // Revalidate every hour
export const dynamic = 'force-static'; // Force static generation
export const fetchCache = 'default-cache';

// Fetch with caching
const response = await fetch('https://api.example.com/data', {
  next: {
    revalidate: 3600,
    tags: ['api-data']
  }
});

// React cache for request deduplication
import { cache } from 'react';

export const getFarm = cache(async (id: string) => {
  return await database.farm.findUnique({ where: { id } });
});

// Multiple calls in same request only execute once
const farm1 = await getFarm('123');
const farm2 = await getFarm('123'); // Uses cached result
```

## üß™ TESTING PATTERNS (Comprehensive Coverage)

### Test Organization
```typescript
// tests/unit/services/farm.service.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { FarmService } from '@/lib/services/farm.service';
import { FarmRepository } from '@/lib/repositories/farm.repository';
import { createMockFarm, createMockUser } from '@/tests/factories';

describe('FarmService', () => {
  let farmService: FarmService;
  let mockRepository: jest.Mocked<FarmRepository>;

  beforeEach(() => {
    mockRepository = {
      create: vi.fn(),
      findById: vi.fn(),
      findByOwner: vi.fn(),
      update: vi.fn(),
      delete: vi.fn()
    } as any;

    farmService = new FarmService(mockRepository);
  });

  describe('createFarm', () => {
    it('should create a farm with valid data', async () => {
      // Arrange
      const farmData = {
        name: 'Green Valley Farm',
        description: 'Organic vegetables',
        ownerId: 'user_123'
      };
      const expectedFarm = createMockFarm(farmData);
      mockRepository.create.mockResolvedValue(expectedFarm);

      // Act
      const result = await farmService.createFarm(farmData);

      // Assert
      expect(result).toEqual(expectedFarm);
      expect(mockRepository.create).toHaveBeenCalledWith({
        ...farmData,
        slug: expect.any(String),
        status: 'PENDING_VERIFICATION'
      });
    });

    it('should throw ValidationError for invalid data', async () => {
      // Arrange
      const invalidData = { name: 'AB' }; // Too short

      // Act & Assert
      await expect(farmService.createFarm(invalidData as any))
        .rejects
        .toThrow(ValidationError);
    });

    it('should handle duplicate farm names', async () => {
      // Arrange
      const farmData = { name: 'Existing Farm', ownerId: 'user_123' };
      mockRepository.create.mockRejectedValue(
        new Prisma.PrismaClientKnownRequestError('Unique constraint', {
          code: 'P2002',
          clientVersion: '5.0.0'
        })
      );

      // Act & Assert
      await expect(farmService.createFarm(farmData))
        .rejects
        .toThrow('Farm name already exists');
    });
  });

  describe('getFarmById', () => {
    it('should return farm when found', async () => {
      // Arrange
      const farm = createMockFarm();
      mockRepository.findById.mockResolvedValue(farm);

      // Act
      const result = await farmService.getFarmById(farm.id);

      // Assert
      expect(result).toEqual(farm);
      expect(mockRepository.findById).toHaveBeenCalledWith(farm.id);
    });

    it('should return null when farm not found', async () => {
      // Arrange
      mockRepository.findById.mockResolvedValue(null);

      // Act
      const result = await farmService.getFarmById('non-existent');

      // Assert
      expect(result).toBeNull();
    });
  });
});
```

### Integration Tests
```typescript
// tests/integration/api/farms.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createTestDatabase, cleanupTestDatabase } from '@/tests/helpers/database';
import { createTestUser, createAuthToken } from '@/tests/helpers/auth';

describe('POST /api/v1/farms', () => {
  let testDb: TestDatabase;
  let authToken: string;
  let userId: string;

  beforeAll(async () => {
    testDb = await createTestDatabase();
    const user = await createTestUser({ role: 'FARMER' });
    userId = user.id;
    authToken = await createAuthToken(user);
  });

  afterAll(async () => {
    await cleanupTestDatabase(testDb);
  });

  it('should create a farm with valid data', async () => {
    // Arrange
    const farmData = {
      name: 'Test Farm',
      description: 'Test Description',
      location: {
        address: '123 Farm Road',
        city: 'Farmville',
        state: 'CA',
        zipCode: '12345',
        coordinates: { lat: 40.7128, lng: -74.0060 }
      }
    };

    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(farmData)
    });

    // Assert
    expect(response.status).toBe(201);
    const result = await response.json();
    expect(result.success).toBe(true);
    expect(result.data).toMatchObject({
      name: farmData.name,
      description: farmData.description,
      ownerId: userId,
      status: 'PENDING_VERIFICATION'
    });
  });

  it('should return 401 when not authenticated', async () => {
    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Test' })
    });

    // Assert
    expect(response.status).toBe(401);
  });

  it('should return 400 with validation errors', async () => {
    // Arrange - Invalid data (name too short)
    const invalidData = { name: 'AB' };

    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(invalidData)
    });

    // Assert
    expect(response.status).toBe(400);
    const result = await response.json();
    expect(result.success).toBe(false);
    expect(result.error.code).toBe('VALIDATION_ERROR');
  });
});
```

### E2E Tests with Playwright
```typescript
// tests/e2e/farm-creation.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Farm Creation Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Login as farmer
    await page.goto('/login');
    await page.fill('input[name="email"]', 'farmer@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('should create a new farm successfully', async ({ page }) => {
    // Navigate to create farm page
    await page.goto('/farms/create');

    // Fill form
    await page.fill('input[name="name"]', 'E2E Test Farm');
    await page.fill('textarea[name="description"]', 'This is a test farm');
    await page.fill('input[name="address"]', '123 Farm Road');
    await page.fill('input[name="city"]', 'Farmville');
    await page.selectOption('select[name="state"]', 'CA');
    await page.fill('input[name="zipCode"]', '12345');

    // Upload image
    await page.setInputFiles('input[type="file"]', './tests/fixtures/farm-image.jpg');

    // Submit form
    await page.click('button[type="submit"]');

    // Wait for success message
    await expect(page.locator('text=Farm created successfully')).toBeVisible();

    // Verify redirect to farm page
    await expect(page).toHaveURL(/\/farms\/farm_\w+/);

    // Verify farm details are displayed
    await expect(page.locator('h1')).toHaveText('E2E Test Farm');
    await expect(page.locator('text=This is a test farm')).toBeVisible();
  });

  test('should show validation errors for invalid data', async ({ page }) => {
    await page.goto('/farms/create');

    // Submit empty form
    await page.click('button[type="submit"]');

    // Check for validation errors
    await expect(page.locator('text=Farm name is required')).toBeVisible();
    await expect(page.locator('text=Description is required')).toBeVisible();
  });
});
```

## üîí SECURITY PATTERNS (Enterprise Grade)

### Authentication & Authorization
```typescript
// lib/auth/index.ts
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { database } from "@/lib/database";
import { comparePasswords } from "@/lib/auth/password";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(database),
  session: { strategy: "jwt" },
  pages: {
    signIn: "/login",
    error: "/auth/error",
  },
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Invalid credentials");
        }

        const user = await database.user.findUnique({
          where: { email: credentials.email },
          include: { roles: true }
        });

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isValid = await comparePasswords(
          credentials.password,
          user.password
        );

        if (!isValid) {
          throw new Error("Invalid credentials");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.roles[0]?.name ?? 'CUSTOMER'
        };
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    }
  }
};

// Middleware for API protection
export async function requireAuth(request: NextRequest) {
  const session = await auth();

  if (!session?.user) {
    throw new UnauthorizedError("Authentication required");
  }

  return session;
}

// Role-based authorization
export async function requireRole(
  request: NextRequest,
  allowedRoles: string[]
) {
  const session = await requireAuth(request);

  if (!allowedRoles.includes(session.user.role)) {
    throw new ForbiddenError(
      `Requires one of: ${allowedRoles.join(', ')}`
    );
  }

  return session;
}

// Resource ownership check
export async function requireOwnership(
  userId: string,
  resourceId: string,
  resourceType: 'farm' | 'product' | 'order'
) {
  const isOwner = await checkOwnership(userId, resourceId, resourceType);

  if (!isOwner) {
    throw new ForbiddenError("You don't have permission to access this resource");
  }
}
```

### Input Validation (Zod Schemas)
```typescript
// lib/validators/farm.validator.ts
import { z } from "zod";

// Coordinate schema
const CoordinateSchema = z.object({
  lat: z.number().min(-90).max(90),
  lng: z.number().min(-180).max(180)
});

// Location schema
const LocationSchema = z.object({
  address: z.string().min(5).max(200),
  city: z.string().min(2).max(100),
  state: z.string().length(2).regex(/^[A-Z]{2}$/),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/),
  coordinates: CoordinateSchema
});

// Create farm schema
export const CreateFarmSchema = z.object({
  name: z.string()
    .min(3, "Farm name must be at least 3 characters")
    .max(100, "Farm name must not exceed 100 characters")
    .regex(/^[a-zA-Z0-9\s\-']+$/, "Farm name contains invalid characters"),

  description: z.string()
    .min(10, "Description must be at least 10 characters")
    .max(2000, "Description must not exceed 2000 characters"),

  location: LocationSchema,

  certifications: z.array(z.enum([
    'ORGANIC',
    'NON_GMO',
    'BIODYNAMIC',
    'RAINFOREST_ALLIANCE',
    'FAIR_TRADE'
  ])).optional().default([]),

  farmSize: z.number()
    .positive("Farm size must be positive")
    .max(100000, "Farm size seems unrealistic"),

  establishedYear: z.number()
    .min(1800, "Established year seems too old")
    .max(new Date().getFullYear(), "Cannot be established in the future"),

  contactEmail: z.string().email("Invalid email address"),

  contactPhone: z.string()
    .regex(/^\+?1?\d{10,14}$/, "Invalid phone number format")
    .optional(),

  website: z.string().url("Invalid website URL").optional(),

  farmingPractices: z.array(z.enum([
    'ORGANIC',
    'CONVENTIONAL',
    'PERMACULTURE',
    'HYDROPONIC',
    'AQUAPONIC',
    'REGENERATIVE'
  ])).min(1, "Select at least one farming practice")
});

// Update farm schema (partial)
export const UpdateFarmSchema = CreateFarmSchema.partial();

// Query filters schema
export const FarmFiltersSchema = z.object({
  search: z.string().max(100).optional(),
  state: z.string().length(2).optional(),
  certifications: z.array(z.string()).optional(),
  practices: z.array(z.string()).optional(),
  minSize: z.number().positive().optional(),
  maxSize: z.number().positive().optional(),
  page: z.number().positive().default(1),
  pageSize: z.number().min(1).max(100).default(20),
  sortBy: z.enum(['name', 'createdAt', 'size']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// Type inference
export type CreateFarmInput = z.infer<typeof CreateFarmSchema>;
export type UpdateFarmInput = z.infer<typeof UpdateFarmSchema>;
export type FarmFilters = z.infer<typeof FarmFiltersSchema>;
```

### SQL Injection Prevention
```typescript
// ‚úÖ SAFE - Parameterized queries (Prisma)
const farms = await database.farm.findMany({
  where: { name: { contains: userInput } } // Automatically escaped
});

// ‚úÖ SAFE - Raw queries with parameters
const result = await database.$queryRaw`
  SELECT * FROM "Farm"
  WHERE name ILIKE ${`%${userInput}%`}
`;

// ‚ùå DANGEROUS - String concatenation
const result = await database.$queryRawUnsafe(
  `SELECT * FROM "Farm" WHERE name = '${userInput}'` // SQL injection risk!
);
```

### XSS Prevention
```typescript
// ‚úÖ React automatically escapes content
<div>{userInput}</div> // Safe

// ‚ùå Dangerous - dangerouslySetInnerHTML
<div dangerouslySetInnerHTML={{ __html: userInput }} /> // XSS risk!

// ‚úÖ If HTML needed, sanitize first
import DOMPurify from 'isomorphic-dompurify';

const SafeHTML = ({ content }: { content: string }) => {
  const sanitized = DOMPurify.sanitize(content);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
};
```

### CSRF Protection
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // CSRF token validation for state-changing operations
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {
    const token = request.headers.get('x-csrf-token');
    const cookieToken = request.cookies.get('csrf-token')?.value;

    if (!token || token !== cookieToken) {
      return NextResponse.json(
        { error: 'Invalid CSRF token' },
        { status: 403 }
      );
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/api/:path*'
};
```

## üìä PERFORMANCE OPTIMIZATION (Claude Sonnet 4.5 Advanced)

### Multi-Layer Caching Strategy
```typescript
// lib/cache/index.ts
import { Redis } from 'ioredis';
import { LRUCache } from 'lru-cache';

// L1: In-memory cache (fastest, 64GB RAM available)
const memoryCache = new LRUCache<string, any>({
  max: 10000,
  ttl: 1000 * 60 * 5, // 5 minutes
  updateAgeOnGet: true,
  updateAgeOnHas: true
});

// L2: Redis cache (fast, shared across instances)
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT ?? '6379'),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  enableReadyCheck: true,
  lazyConnect: true
});

// Multi-layer cache implementation
export class CacheService {
  async get<T>(key: string): Promise<T | null> {
    // L1: Check memory cache
    const memCached = memoryCache.get(key);
    if (memCached) {
      logger.debug('Cache hit (memory)', { key });
      return memCached as T;
    }

    // L2: Check Redis
    const redisCached = await redis.get(key);
    if (redisCached) {
      logger.debug('Cache hit (redis)', { key });
      const parsed = JSON.parse(redisCached);

      // Store in memory for next time
      memoryCache.set(key, parsed);

      return parsed as T;
    }

    logger.debug('Cache miss', { key });
    return null;
  }

  async set<T>(
    key: string,
    value: T,
    ttl: number = 3600
  ): Promise<void> {
    // Set in both layers
    memoryCache.set(key, value);
    await redis.setex(key, ttl, JSON.stringify(value));

    logger.debug('Cache set', { key, ttl });
  }

  async invalidate(pattern: string): Promise<void> {
    // Clear memory cache
    memoryCache.clear();

    // Clear Redis keys matching pattern
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }

    logger.info('Cache invalidated', { pattern, keysCleared: keys.length });
  }

  async wrap<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl: number = 3600
  ): Promise<T> {
    // Try to get from cache
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // Fetch fresh data
    const fresh = await fetcher();

    // Cache it
    await this.set(key, fresh, ttl);

    return fresh;
  }
}

export const cache = new CacheService();
```

### Database Query Optimization
```typescript
// lib/repositories/optimized-farm.repository.ts
export class OptimizedFarmRepository extends FarmRepository {

  // Efficient pagination with total count
  async findManyWithCount(filters: FarmFilters) {
    const where = this.buildWhereClause(filters);

    // Parallel execution
    const [items, total] = await Promise.all([
      database.farm.findMany({
        where,
        skip: (filters.page - 1) * filters.pageSize,
        take: filters.pageSize,
        orderBy: { [filters.sortBy]: filters.sortOrder },
        select: this.getOptimizedSelect() // Only needed fields
      }),
      database.farm.count({ where })
    ]);

    return { items, total };
  }

  // Optimized select to reduce payload
  private getOptimizedSelect() {
    return {
      id: true,
      name: true,
      slug: true,
      description: true,
      status: true,
      location: {
        select: {
          city: true,
          state: true,
          coordinates: true
        }
      },
      owner: {
        select: {
          id: true,
          name: true,
          avatar: true
        }
      },
      _count: {
        select: {
          products: true,
          reviews: true
        }
      },
      createdAt: true,
      updatedAt: true
    };
  }

  // Batch loading to prevent N+1
  async loadProductsForFarms(farmIds: string[]) {
    const products = await database.product.findMany({
      where: { farmId: { in: farmIds } },
      select: {
        id: true,
        name: true,
        price: true,
        farmId: true
      }
    });

    // Group by farm ID
    return products.reduce((acc, product) => {
      if (!acc[product.farmId]) {
        acc[product.farmId] = [];
      }
      acc[product.farmId].push(product);
      return acc;
    }, {} as Record<string, typeof products>);
  }

  // Efficient search with full-text
  async searchFarmsFullText(query: string) {
    return await database.$queryRaw`
      SELECT
        f.*,
        ts_rank(
          to_tsvector('english', f.name || ' ' || f.description),
          plainto_tsquery('english', ${query})
        ) as rank
      FROM "Farm" f
      WHERE to_tsvector('english', f.name || ' ' || f.description)
        @@ plainto_tsquery('english', ${query})
      ORDER BY rank DESC
      LIMIT 20
    `;
  }
}
```

### Image Optimization
```typescript
// components/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width: number;
  height: number;
  priority?: boolean;
  className?: string;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  priority = false,
  className
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);

  return (
    <div className={`relative overflow-hidden ${className}`}>
      <Image
        src={src}
        alt={alt}
        width={width}
        height={height}
        priority={priority}
        quality={85} // Optimal quality/size ratio
        placeholder="blur"
        blurDataURL="data:image/svg+xml;base64,..." // Low quality placeholder
        onLoadingComplete={() => setIsLoading(false)}
        className={`
          duration-300 ease-in-out
          ${isLoading ? 'scale-110 blur-lg' : 'scale-100 blur-0'}
        `}
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      />
    </div>
  );
}
```

### Bundle Optimization
```typescript
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Compiler optimizations
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },

  // Bundle analyzer
  webpack: (config, { dev, isServer }) => {
    // Bundle analyzer in development
    if (!dev && !isServer) {
      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          reportFilename: './bundle-analysis.html',
          openAnalyzer: false
        })
      );
    }

    // Optimize chunks
    config.optimization = {
      ...config.optimization,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          // Vendor chunk for stable caching
          vendor: {
            name: 'vendor',
            chunks: 'all',
            test: /node_modules/,
            priority: 20
          },
          // Common chunk for shared code
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'async',
            priority: 10,
            reuseExistingChunk: true,
            enforce: true
          }
        }
      }
    };

    return config;
  },

  // Image optimization
  images: {
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 60 * 60 * 24 * 365 // 1 year
  },

  // Production optimizations
  productionBrowserSourceMaps: false,
  poweredByHeader: false,
  compress: true
};

export default nextConfig;
```

## üåæ AGRICULTURAL CONSCIOUSNESS (Domain Intelligence)

### Seasonal Awareness System
```typescript
// lib/domain/seasons.ts
export enum Season {
  SPRING = 'SPRING',
  SUMMER = 'SUMMER',
  FALL = 'FALL',
  WINTER = 'WINTER'
}

export enum LunarPhase {
  NEW_MOON = 'NEW_MOON',
  WAXING_CRESCENT = 'WAXING_CRESCENT',
  FIRST_QUARTER = 'FIRST_QUARTER',
  WAXING_GIBBOUS = 'WAXING_GIBBOUS',
  FULL_MOON = 'FULL_MOON',
  WANING_GIBBOUS = 'WANING_GIBBOUS',
  LAST_QUARTER = 'LAST_QUARTER',
  WANING_CRESCENT = 'WANING_CRESCENT'
}

// Agricultural operations by season
export const SEASONAL_OPERATIONS = {
  [Season.SPRING]: ['PLANT', 'PREPARE_SOIL', 'FERTILIZE', 'PRUNE'],
  [Season.SUMMER]: ['WATER', 'WEED', 'MONITOR', 'HARVEST_EARLY'],
  [Season.FALL]: ['HARVEST', 'PRESERVE', 'COMPOST', 'PREPARE_WINTER'],
  [Season.WINTER]: ['REST', 'PLAN', 'REPAIR', 'INDOOR_GROWING']
} as const;

// Biodynamic calendar integration
export class BiodynamicCalendar {
  getCurrentSeason(): Season {
    const month = new Date().getMonth();
    if (month >= 2 && month <= 4) return Season.SPRING;
    if (month >= 5 && month <= 7) return Season.SUMMER;
    if (month >= 8 && month <= 10) return Season.FALL;
    return Season.WINTER;
  }

  getCurrentLunarPhase(): LunarPhase {
    // Lunar phase calculation
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const day = now.getDate();

    // Simplified lunar phase calculation
    const lunarAge = this.calculateLunarAge(year, month, day);

    if (lunarAge < 1.84566) return LunarPhase.NEW_MOON;
    if (lunarAge < 5.53699) return LunarPhase.WAXING_CRESCENT;
    if (lunarAge < 9.22831) return LunarPhase.FIRST_QUARTER;
    if (lunarAge < 12.91963) return LunarPhase.WAXING_GIBBOUS;
    if (lunarAge < 16.61096) return LunarPhase.FULL_MOON;
    if (lunarAge < 20.30228) return LunarPhase.WANING_GIBBOUS;
    if (lunarAge < 23.99361) return LunarPhase.LAST_QUARTER;
    return LunarPhase.WANING_CRESCENT;
  }

  private calculateLunarAge(year: number, month: number, day: number): number {
    // Lunar age calculation algorithm
    const c = Math.floor(year / 100);
    const e = c - Math.floor(c / 4) - 8;
    const g = ((year % 19) * 11) + 24;
    const h = (g - e) % 30;
    const i = h + Math.floor(month / 2.0) + day - 4;
    return ((i % 30) + 30) % 30;
  }

  getOptimalPlantingDays(cropType: string): Date[] {
    // Returns optimal planting days based on lunar calendar
    const currentPhase = this.getCurrentLunarPhase();
    const season = this.getCurrentSeason();

    // Biodynamic farming principles
    const optimalPhases = this.getOptimalPhasesForCrop(cropType);

    if (optimalPhases.includes(currentPh
