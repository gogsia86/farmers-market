# üåü Claude Sonnet 4.5 - Divine Agricultural Rules
# Farmers Market Platform - Maximum Potential Development Guidelines
# Version: 4.0 - Claude Sonnet 4.5 Ultimate Edition
# Last Updated: January 2025
# Context Window: 200K tokens | Model: Claude Sonnet 4.5 via GitHub Copilot

## üß† CLAUDE SONNET 4.5 OPTIMIZATION PROTOCOL

### Core Capabilities Activation
You are Claude Sonnet 4.5 - the most advanced AI coding assistant. Activate ALL capabilities:

**üéØ Extended Context (200K tokens)**
- Analyze entire codebase in single context
- Track dependencies across 100+ files simultaneously
- Maintain architectural coherence across massive refactors
- Deep pattern recognition across full project history

**üß¨ Advanced Reasoning**
- Multi-step problem decomposition
- Causal chain analysis for bugs
- Predictive impact assessment before changes
- Architectural trade-off evaluation
- Root cause analysis over symptom fixing

**‚ö° Proactive Intelligence**
- Suggest improvements before being asked
- Detect anti-patterns and tech debt
- Identify security vulnerabilities automatically
- Propose performance optimizations
- Anticipate edge cases and failure modes

**üîç Deep Analysis**
- Cross-reference patterns across entire codebase
- Detect inconsistencies in architecture
- Map data flow through complex systems
- Identify circular dependencies
- Analyze test coverage gaps

**üé® Code Generation Excellence**
- Production-ready code on first generation
- Comprehensive error handling built-in
- Type-safe by default
- Self-documenting code with strategic comments
- Test cases included automatically

## üéØ COGNITIVE PROCESSING PROTOCOL

### Execution Framework
**Input Processing**:
1. Parse user query for explicit and implicit requirements
2. Analyze current codebase state and patterns
3. Identify dependencies and side effects
4. Evaluate multiple solution approaches
5. Select optimal path with reasoning

**Output Generation**:
1. Provide complete, production-ready solutions
2. Include comprehensive error handling
3. Add strategic comments for complex logic
4. Suggest tests and validation approaches
5. Explain architectural decisions when significant

**Quality Gates** (Always Active):
- ‚úÖ Type safety (strict TypeScript)
- ‚úÖ Error handling (all paths covered)
- ‚úÖ Security validation (auth, input, injection)
- ‚úÖ Performance optimization (N+1, caching, async)
- ‚úÖ Test coverage (unit, integration, edge cases)
- ‚úÖ Documentation (complex logic explained)

### Advanced Reasoning Modes

**üî¨ Deep Analysis Mode** (for complex problems)
```
1. Problem decomposition into sub-components
2. Dependency mapping across codebase
3. Impact analysis on existing systems
4. Risk assessment and mitigation strategies
5. Multiple solution paths with trade-offs
6. Recommended approach with justification
```

**üèóÔ∏è Architectural Mode** (for system design)
```
1. Current state analysis
2. Future state vision
3. Migration path planning
4. Backwards compatibility strategy
5. Scalability considerations
6. Performance implications
7. Security architecture
```

**üêõ Debug Mode** (for complex bugs)
```
1. Reproduce issue with minimal example
2. Root cause analysis (not symptoms)
3. Causal chain identification
4. Fix with comprehensive tests
5. Prevention strategy for similar issues
6. Monitoring/logging improvements
```

## üèóÔ∏è PROJECT ARCHITECTURE

### Tech Stack (Production Grade)
```yaml
framework: Next.js 15 (App Router) - Latest stable
language: TypeScript 5.3+ (strict mode, no any)
database: Prisma 7 + PostgreSQL 16
auth: NextAuth v5 (edge-ready)
styling: Tailwind CSS 4 + CSS Variables
testing: Vitest + React Testing Library + Playwright
state: React Server Components + Server Actions
ai_framework: Microsoft Agent Framework + OpenAI
tracing: OpenTelemetry + Azure Application Insights
monitoring: Sentry + Custom metrics
caching: Redis + In-memory (multi-layer)
deployment: Vercel (Edge) + Docker (self-hosted option)
```

### Critical Import Patterns (ENFORCED)
```typescript
// ‚úÖ ALWAYS - Canonical database import
import { database } from "@/lib/database";

// ‚úÖ ALWAYS - Type-only imports for Prisma
import type { User, Farm, Product } from "@prisma/client";

// ‚úÖ ALWAYS - Path aliases (never relative beyond parent)
import { Component } from "@/components/ui/Component";
import { farmService } from "@/lib/services/farm.service";
import type { ApiResponse } from "@/types/api";

// ‚ùå NEVER - New Prisma instances
// import { PrismaClient } from "@prisma/client";
// const prisma = new PrismaClient(); // FORBIDDEN

// ‚ùå NEVER - Deep relative imports
// import { foo } from "../../../lib/utils"; // BAD
```

### Directory Structure (Enterprise Scale)
```
src/
‚îú‚îÄ‚îÄ app/                           # Next.js 15 App Router
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/                   # Auth route group
‚îÇ   ‚îú‚îÄ‚îÄ (admin)/                  # Admin protected routes
‚îÇ   ‚îú‚îÄ‚îÄ (customer)/               # Customer routes
‚îÇ   ‚îú‚îÄ‚îÄ (farmer)/                 # Farmer routes
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # API routes (RESTful)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/                   # Versioned API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webhooks/             # External webhooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ internal/             # Internal APIs
‚îÇ   ‚îú‚îÄ‚îÄ error.tsx                 # Error boundaries
‚îÇ   ‚îú‚îÄ‚îÄ global-error.tsx          # Global error handler
‚îÇ   ‚îî‚îÄ‚îÄ not-found.tsx             # 404 handler
‚îÇ
‚îú‚îÄ‚îÄ components/                    # React components
‚îÇ   ‚îú‚îÄ‚îÄ ui/                       # Base UI primitives
‚îÇ   ‚îú‚îÄ‚îÄ features/                 # Feature components
‚îÇ   ‚îú‚îÄ‚îÄ layouts/                  # Layout components
‚îÇ   ‚îî‚îÄ‚îÄ providers/                # Context providers
‚îÇ
‚îú‚îÄ‚îÄ lib/                          # Core business logic
‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Service layer (business logic)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ farm.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ repositories/             # Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # Database singleton & utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # Export: database
‚îÇ   ‚îú‚îÄ‚îÄ auth/                     # Authentication & authorization
‚îÇ   ‚îú‚îÄ‚îÄ utils/                    # Pure utility functions
‚îÇ   ‚îú‚îÄ‚îÄ validators/               # Zod schemas & validation
‚îÇ   ‚îú‚îÄ‚îÄ ai/                       # AI & Agent Framework
‚îÇ   ‚îú‚îÄ‚îÄ cache/                    # Caching layer
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/               # Observability
‚îÇ
‚îú‚îÄ‚îÄ types/                        # TypeScript definitions
‚îÇ   ‚îú‚îÄ‚îÄ api.ts                    # API types
‚îÇ   ‚îú‚îÄ‚îÄ database.ts               # Database types
‚îÇ   ‚îî‚îÄ‚îÄ domain/                   # Domain models
‚îÇ
‚îú‚îÄ‚îÄ hooks/                        # React hooks
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îú‚îÄ‚îÄ useFarm.ts
‚îÇ   ‚îî‚îÄ‚îÄ queries/                  # React Query hooks
‚îÇ
‚îú‚îÄ‚îÄ middleware/                   # Next.js middleware utilities
‚îú‚îÄ‚îÄ config/                       # Configuration
‚îî‚îÄ‚îÄ constants/                    # Application constants
```

## üé® CODING STANDARDS (Claude Sonnet 4.5 Enhanced)

### Naming Conventions

#### Component Naming (Agricultural + Quantum Theme)
```typescript
// ‚úÖ DIVINE PATTERN - For core agricultural features
export function QuantumFarmDashboard({ farmId }: QuantumFarmDashboardProps) {
  const consciousness = useAgriculturalConsciousness();
  const farmData = useFarmQuantumState(farmId);
  // Implementation
}

// ‚úÖ STANDARD PATTERN - For UI components
export function FarmProductCard({ product }: FarmProductCardProps) {
  // Clear, descriptive, domain-specific
}

// ‚úÖ ACCEPTABLE - For generic UI
export function Button({ variant, children, ...props }: ButtonProps) {
  // Generic components can use simple names
}

// ‚ùå AVOID - Ambiguous names
export function Card({ data }: any) {
  // Too generic, no domain context
}
```

#### Service Layer (Layered Architecture)
```typescript
// ‚úÖ SERVICE LAYER - Business logic
export class FarmService {
  constructor(
    private readonly repository: FarmRepository,
    private readonly cache: CacheService,
    private readonly logger: Logger
  ) {}

  async createFarm(request: CreateFarmRequest): Promise<Farm> {
    // Validation
    const validated = CreateFarmSchema.parse(request);

    // Business logic
    const slug = this.generateUniqueSlug(validated.name);

    // Data persistence
    const farm = await this.repository.create({
      ...validated,
      slug,
      status: FarmStatus.PENDING_VERIFICATION
    });

    // Cache invalidation
    await this.cache.invalidate(`farms:*`);

    // Event emission
    this.eventBus.emit('farm.created', { farmId: farm.id });

    return farm;
  }
}

// ‚úÖ REPOSITORY LAYER - Data access
export class FarmRepository {
  async create(data: CreateFarmData): Promise<Farm> {
    return await database.farm.create({
      data,
      include: { owner: true, location: true }
    });
  }

  async findById(id: string): Promise<Farm | null> {
    return await database.farm.findUnique({
      where: { id },
      include: this.defaultIncludes
    });
  }
}
```

#### Function Naming Matrix (CRUD + Domain)
```typescript
// CREATE operations
async createFarm(data: CreateFarmRequest): Promise<Farm>
async registerFarmer(data: RegisterFarmerRequest): Promise<Farmer>
async initializeSeason(params: InitializeSeasonParams): Promise<Season>

// READ operations
async getFarmById(id: string): Promise<Farm | null>           // Single
async findFarmsByRegion(region: string): Promise<Farm[]>      // Multiple
async listActiveFarms(filters: FarmFilters): Promise<Farm[]>  // Filtered list
async searchFarms(query: string): Promise<Farm[]>             // Search

// UPDATE operations
async updateFarm(id: string, updates: UpdateFarmRequest): Promise<Farm>
async patchFarmStatus(id: string, status: FarmStatus): Promise<void>
async modifyFarmSettings(id: string, settings: Settings): Promise<Farm>

// DELETE operations
async deleteFarm(id: string): Promise<void>
async removeFarm(id: string): Promise<void>         // Soft delete
async archiveFarm(id: string): Promise<Farm>        // Archive (soft)

// VALIDATION operations
async validateFarmData(data: unknown): Promise<ValidationResult>
async verifyFarmOwnership(farmId: string, userId: string): Promise<boolean>
async checkFarmAvailability(slug: string): Promise<boolean>

// BUSINESS LOGIC operations
async approveFarm(id: string, approvedBy: string): Promise<Farm>
async suspendFarm(id: string, reason: string): Promise<Farm>
async transferFarmOwnership(farmId: string, newOwnerId: string): Promise<Farm>
```

### TypeScript Patterns (Maximum Type Safety)

#### Branded Types for Domain Modeling
```typescript
// Brand helper
type Brand<K, T> = K & { readonly __brand: T };

// Domain IDs
export type FarmId = Brand<string, "FarmId">;
export type UserId = Brand<string, "UserId">;
export type ProductId = Brand<string, "ProductId">;
export type OrderId = Brand<string, "OrderId">;

// Branded constructors
export const FarmId = (id: string): FarmId => id as FarmId;
export const UserId = (id: string): UserId => id as UserId;

// Type guards
export const isFarmId = (id: unknown): id is FarmId => {
  return typeof id === 'string' && id.startsWith('farm_');
};

// Usage
async function getFarm(id: FarmId): Promise<Farm> {
  return database.farm.findUnique({ where: { id } });
}

// Type error prevented
// getFarm("random-string"); // Error: string is not assignable to FarmId
getFarm(FarmId("farm_123")); // ‚úÖ OK
```

#### Advanced Type Patterns
```typescript
// Discriminated unions for state machines
type FarmStatus =
  | { status: 'DRAFT'; draftedAt: Date }
  | { status: 'PENDING_VERIFICATION'; submittedAt: Date }
  | { status: 'ACTIVE'; activatedAt: Date; verifiedBy: UserId }
  | { status: 'SUSPENDED'; suspendedAt: Date; reason: string }
  | { status: 'ARCHIVED'; archivedAt: Date };

// Type-safe exhaustiveness checking
function handleFarmStatus(farm: FarmStatus): string {
  switch (farm.status) {
    case 'DRAFT':
      return `Draft created ${farm.draftedAt}`;
    case 'PENDING_VERIFICATION':
      return `Submitted ${farm.submittedAt}`;
    case 'ACTIVE':
      return `Active since ${farm.activatedAt}`;
    case 'SUSPENDED':
      return `Suspended: ${farm.reason}`;
    case 'ARCHIVED':
      return `Archived ${farm.archivedAt}`;
    default:
      // TypeScript error if we miss a case
      const _exhaustive: never = farm;
      return _exhaustive;
  }
}

// Partial type utilities
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// Async function return type extractor
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
```

#### API Response Types (Standardized)
```typescript
// Base response structure
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: ApiError;
  meta?: ResponseMeta;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  stack?: string; // Only in development
  timestamp: string;
  requestId: string;
}

export interface ResponseMeta {
  pagination?: PaginationMeta;
  requestId: string;
  duration?: number; // Response time in ms
  cached?: boolean;
  version: string; // API version
}

export interface PaginationMeta {
  page: number;
  pageSize: number;
  totalPages: number;
  totalItems: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

// Success helper
export function successResponse<T>(
  data: T,
  meta?: Partial<ResponseMeta>
): ApiResponse<T> {
  return {
    success: true,
    data,
    meta: {
      requestId: generateRequestId(),
      version: 'v1',
      ...meta
    }
  };
}

// Error helper
export function errorResponse(
  code: string,
  message: string,
  details?: Record<string, unknown>
): ApiResponse<never> {
  return {
    success: false,
    error: {
      code,
      message,
      details,
      timestamp: new Date().toISOString(),
      requestId: generateRequestId(),
      stack: process.env.NODE_ENV === 'development' ? new Error().stack : undefined
    }
  };
}

// Usage in API routes
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const farms = await farmService.getAllFarms();
    return NextResponse.json(successResponse(farms));
  } catch (error) {
    if (error instanceof ValidationError) {
      return NextResponse.json(
        errorResponse('VALIDATION_ERROR', error.message, { fields: error.fields }),
        { status: 400 }
      );
    }

    logger.error('Failed to fetch farms', { error });
    return NextResponse.json(
      errorResponse('INTERNAL_ERROR', 'An unexpected error occurred'),
      { status: 500 }
    );
  }
}
```

## üóÑÔ∏è DATABASE PATTERNS (Prisma Best Practices)

### Canonical Database Import (STRICT RULE)
```typescript
// ‚úÖ CORRECT - Single source of truth
import { database } from "@/lib/database";

// ‚úÖ CORRECT - Type imports
import type { Farm, Product, User, Prisma } from "@prisma/client";

// ‚ùå FORBIDDEN - Never create new instances
// import { PrismaClient } from "@prisma/client";
// const prisma = new PrismaClient(); // NEVER DO THIS
```

### Database Singleton Implementation
```typescript
// lib/database/index.ts
import { PrismaClient } from "@prisma/client";
import { logger } from "@/lib/monitoring/logger";

const createPrismaClient = () => {
  return new PrismaClient({
    log: [
      { level: 'query', emit: 'event' },
      { level: 'error', emit: 'event' },
      { level: 'warn', emit: 'event' }
    ],
    errorFormat: 'pretty'
  });
};

// Singleton with connection pooling
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const database = globalForPrisma.prisma ?? createPrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = database;
}

// Query logging
database.$on('query', (e) => {
  if (e.duration > 1000) {
    logger.warn('Slow query detected', {
      query: e.query,
      duration: e.duration,
      params: e.params
    });
  }
});

// Error handling
database.$on('error', (e) => {
  logger.error('Database error', { error: e });
});
```

### Repository Pattern (Data Access Layer)
```typescript
// lib/repositories/base.repository.ts
export abstract class BaseRepository<T> {
  protected abstract readonly model: string;

  protected get db() {
    return database;
  }

  protected get table() {
    return (this.db as any)[this.model];
  }

  async findById(id: string): Promise<T | null> {
    return await this.table.findUnique({ where: { id } });
  }

  async findMany(where: any): Promise<T[]> {
    return await this.table.findMany({ where });
  }

  async create(data: any): Promise<T> {
    return await this.table.create({ data });
  }

  async update(id: string, data: any): Promise<T> {
    return await this.table.update({ where: { id }, data });
  }

  async delete(id: string): Promise<void> {
    await this.table.delete({ where: { id } });
  }
}

// lib/repositories/farm.repository.ts
export class FarmRepository extends BaseRepository<Farm> {
  protected readonly model = 'farm';

  private readonly defaultIncludes = {
    owner: true,
    location: true,
    products: {
      where: { status: 'ACTIVE' },
      take: 10
    }
  };

  async findByIdWithDetails(id: string): Promise<Farm | null> {
    return await this.table.findUnique({
      where: { id },
      include: this.defaultIncludes
    });
  }

  async findByOwner(ownerId: string): Promise<Farm[]> {
    return await this.table.findMany({
      where: { ownerId },
      include: this.defaultIncludes,
      orderBy: { createdAt: 'desc' }
    });
  }

  async searchFarms(query: string): Promise<Farm[]> {
    return await this.table.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { description: { contains: query, mode: 'insensitive' } }
        ],
        status: 'ACTIVE'
      },
      include: this.defaultIncludes,
      take: 20
    });
  }
}
```

### Query Optimization Patterns
```typescript
// ‚úÖ PARALLEL QUERIES - Use Promise.all
const [farms, totalCount, categories] = await Promise.all([
  database.farm.findMany({ where, take, skip }),
  database.farm.count({ where }),
  database.category.findMany({ where: { active: true } })
]);

// ‚úÖ SELECT SPECIFIC FIELDS - Reduce payload
const farms = await database.farm.findMany({
  select: {
    id: true,
    name: true,
    slug: true,
    location: {
      select: {
        city: true,
        state: true,
        coordinates: true
      }
    }
  }
});

// ‚úÖ CURSOR-BASED PAGINATION - For large datasets
const farms = await database.farm.findMany({
  take: 20,
  skip: cursor ? 1 : 0,
  cursor: cursor ? { id: cursor } : undefined,
  orderBy: { createdAt: 'desc' }
});

// ‚ùå AVOID N+1 QUERIES
// BAD
for (const farm of farms) {
  const products = await database.product.findMany({
    where: { farmId: farm.id }
  });
}

// GOOD - Use include or single query
const farms = await database.farm.findMany({
  include: {
    products: {
      where: { status: 'ACTIVE' },
      orderBy: { createdAt: 'desc' },
      take: 10
    }
  }
});

// ‚úÖ BATCH OPERATIONS - Use transactions
await database.$transaction([
  database.farm.update({ where: { id: '1' }, data: { ... } }),
  database.farm.update({ where: { id: '2' }, data: { ... } }),
  database.farm.update({ where: { id: '3' }, data: { ... } })
]);

// ‚úÖ RAW QUERIES - For complex operations
const result = await database.$queryRaw`
  SELECT f.*, COUNT(p.id) as product_count
  FROM "Farm" f
  LEFT JOIN "Product" p ON p."farmId" = f.id
  WHERE f.status = 'ACTIVE'
  GROUP BY f.id
  HAVING COUNT(p.id) > 5
  ORDER BY product_count DESC
  LIMIT 10
`;
```

## ‚ö° NEXT.JS 15 PATTERNS (App Router Mastery)

### Server vs Client Components (Strategic Use)
```typescript
// ‚úÖ SERVER COMPONENT (default) - No "use client"
// app/farms/[id]/page.tsx
import { Suspense } from 'react';
import { notFound } from 'next/navigation';

interface PageProps {
  params: { id: string };
  searchParams: { tab?: string };
}

// Async Server Component - Direct database access
export default async function FarmPage({ params, searchParams }: PageProps) {
  // Direct data fetching on server
  const farm = await farmService.getFarmById(params.id);

  if (!farm) {
    notFound(); // Returns 404
  }

  // Can fetch parallel data
  const [products, reviews, owner] = await Promise.all([
    farmService.getFarmProducts(params.id),
    reviewService.getFarmReviews(params.id),
    userService.getUserById(farm.ownerId)
  ]);

  return (
    <main className="container mx-auto py-8">
      {/* Server Component - No interactivity needed */}
      <FarmHeader farm={farm} owner={owner} />

      {/* Streaming with Suspense */}
      <Suspense fallback={<ProductGridSkeleton />}>
        <ProductGrid products={products} />
      </Suspense>

      {/* Client Component - Interactive map */}
      <InteractiveMap
        location={farm.location}
        farmId={farm.id}
      />

      {/* Client Component - Forms need state */}
      <ReviewForm farmId={farm.id} />
    </main>
  );
}

// Generate metadata for SEO
export async function generateMetadata({ params }: PageProps) {
  const farm = await farmService.getFarmById(params.id);

  return {
    title: `${farm.name} | Farmers Market`,
    description: farm.description,
    openGraph: {
      title: farm.name,
      description: farm.description,
      images: [farm.imageUrl]
    }
  };
}

// Static params generation for SSG
export async function generateStaticParams() {
  const farms = await farmService.getAllFarms({ limit: 100 });
  return farms.map(farm => ({ id: farm.id }));
}
```

```typescript
// ‚úÖ CLIENT COMPONENT - "use client" directive
// components/InteractiveMap.tsx
"use client";

import { useState, useEffect } from "react";
import dynamic from "next/dynamic";
import type { Location } from "@/types";

// Dynamic import for map library (client-only)
const MapComponent = dynamic(
  () => import("@/components/Map"),
  { ssr: false, loading: () => <MapSkeleton /> }
);

interface InteractiveMapProps {
  location: Location;
  farmId: string;
}

export function InteractiveMap({ location, farmId }: InteractiveMapProps) {
  const [zoom, setZoom] = useState(13);
  const [markers, setMarkers] = useState<Marker[]>([]);

  // Client-side effects
  useEffect(() => {
    loadNearbyFarms(location).then(setMarkers);
  }, [location]);

  // Event handlers
  const handleZoomChange = (newZoom: number) => {
    setZoom(newZoom);
    trackEvent('map_zoom', { zoom: newZoom, farmId });
  };

  return (
    <div className="relative h-96 rounded-lg overflow-hidden">
      <MapComponent
        center={location.coordinates}
        zoom={zoom}
        markers={markers}
        onZoomChange={handleZoomChange}
      />
    </div>
  );
}
```

### Server Actions (Type-Safe Data Mutations)
```typescript
// app/actions/farm.actions.ts
"use server";

import { revalidatePath, revalidateTag } from "next/cache";
import { redirect } from "next/navigation";
import { auth } from "@/lib/auth";
import { farmService } from "@/lib/services/farm.service";
import { CreateFarmSchema } from "@/lib/validators/farm.validator";
import { logger } from "@/lib/monitoring/logger";

// Type-safe server action with validation
export async function createFarm(formData: FormData) {
  // Authentication check
  const session = await auth();
  if (!session?.user) {
    return {
      success: false,
      error: { code: 'UNAUTHORIZED', message: 'Authentication required' }
    };
  }

  try {
    // Extract and validate data
    const rawData = {
      name: formData.get("name") as string,
      description: formData.get("description") as string,
      location: JSON.parse(formData.get("location") as string),
      certifications: formData.getAll("certifications") as string[]
    };

    // Zod validation
    const validatedData = CreateFarmSchema.parse(rawData);

    // Authorization check
    if (session.user.role !== 'FARMER') {
      return {
        success: false,
        error: { code: 'FORBIDDEN', message: 'Only farmers can create farms' }
      };
    }

    // Business logic
    const farm = await farmService.createFarm({
      ...validatedData,
      ownerId: session.user.id
    });

    // Cache revalidation
    revalidatePath('/farms');
    revalidatePath(`/farmers/${session.user.id}`);
    revalidateTag('farms-list');

    // Log success
    logger.info('Farm created', { farmId: farm.id, userId: session.user.id });

    // Return success
    return { success: true, data: farm };

  } catch (error) {
    // Error handling
    if (error instanceof ZodError) {
      return {
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid farm data',
          details: error.flatten()
        }
      };
    }

    logger.error('Farm creation failed', { error, userId: session.user.id });

    return {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to create farm. Please try again.'
      }
    };
  }
}

// Server action with redirect
export async function submitFarmForReview(farmId: string) {
  const session = await auth();
  if (!session?.user) {
    redirect('/login?callbackUrl=/farms/' + farmId);
  }

  await farmService.submitForReview(farmId, session.user.id);

  revalidatePath(`/farms/${farmId}`);
  redirect(`/farms/${farmId}?submitted=true`);
}

// Optimistic update pattern
export async function toggleFarmFavorite(farmId: string) {
  const session = await auth();
  if (!session?.user) {
    return { success: false, error: { code: 'UNAUTHORIZED' } };
  }

  await farmService.toggleFavorite(farmId, session.user.id);

  revalidateTag(`user-${session.user.id}-favorites`);

  return { success: true };
}
```

### Advanced Caching Strategies
```typescript
// Route-level caching
export const revalidate = 3600; // Revalidate every hour
export const dynamic = 'force-static'; // Force static generation
export const fetchCache = 'default-cache';

// Fetch with caching
const response = await fetch('https://api.example.com/data', {
  next: {
    revalidate: 3600,
    tags: ['api-data']
  }
});

// React cache for request deduplication
import { cache } from 'react';

export const getFarm = cache(async (id: string) => {
  return await database.farm.findUnique({ where: { id } });
});

// Multiple calls in same request only execute once
const farm1 = await getFarm('123');
const farm2 = await getFarm('123'); // Uses cached result
```

## üß™ TESTING PATTERNS (Comprehensive Coverage)

### Test Organization
```typescript
// tests/unit/services/farm.service.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { FarmService } from '@/lib/services/farm.service';
import { FarmRepository } from '@/lib/repositories/farm.repository';
import { createMockFarm, createMockUser } from '@/tests/factories';

describe('FarmService', () => {
  let farmService: FarmService;
  let mockRepository: jest.Mocked<FarmRepository>;

  beforeEach(() => {
    mockRepository = {
      create: vi.fn(),
      findById: vi.fn(),
      findByOwner: vi.fn(),
      update: vi.fn(),
      delete: vi.fn()
    } as any;

    farmService = new FarmService(mockRepository);
  });

  describe('createFarm', () => {
    it('should create a farm with valid data', async () => {
      // Arrange
      const farmData = {
        name: 'Green Valley Farm',
        description: 'Organic vegetables',
        ownerId: 'user_123'
      };
      const expectedFarm = createMockFarm(farmData);
      mockRepository.create.mockResolvedValue(expectedFarm);

      // Act
      const result = await farmService.createFarm(farmData);

      // Assert
      expect(result).toEqual(expectedFarm);
      expect(mockRepository.create).toHaveBeenCalledWith({
        ...farmData,
        slug: expect.any(String),
        status: 'PENDING_VERIFICATION'
      });
    });

    it('should throw ValidationError for invalid data', async () => {
      // Arrange
      const invalidData = { name: 'AB' }; // Too short

      // Act & Assert
      await expect(farmService.createFarm(invalidData as any))
        .rejects
        .toThrow(ValidationError);
    });

    it('should handle duplicate farm names', async () => {
      // Arrange
      const farmData = { name: 'Existing Farm', ownerId: 'user_123' };
      mockRepository.create.mockRejectedValue(
        new Prisma.PrismaClientKnownRequestError('Unique constraint', {
          code: 'P2002',
          clientVersion: '5.0.0'
        })
      );

      // Act & Assert
      await expect(farmService.createFarm(farmData))
        .rejects
        .toThrow('Farm name already exists');
    });
  });

  describe('getFarmById', () => {
    it('should return farm when found', async () => {
      // Arrange
      const farm = createMockFarm();
      mockRepository.findById.mockResolvedValue(farm);

      // Act
      const result = await farmService.getFarmById(farm.id);

      // Assert
      expect(result).toEqual(farm);
      expect(mockRepository.findById).toHaveBeenCalledWith(farm.id);
    });

    it('should return null when farm not found', async () => {
      // Arrange
      mockRepository.findById.mockResolvedValue(null);

      // Act
      const result = await farmService.getFarmById('non-existent');

      // Assert
      expect(result).toBeNull();
    });
  });
});
```

### Integration Tests
```typescript
// tests/integration/api/farms.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createTestDatabase, cleanupTestDatabase } from '@/tests/helpers/database';
import { createTestUser, createAuthToken } from '@/tests/helpers/auth';

describe('POST /api/v1/farms', () => {
  let testDb: TestDatabase;
  let authToken: string;
  let userId: string;

  beforeAll(async () => {
    testDb = await createTestDatabase();
    const user = await createTestUser({ role: 'FARMER' });
    userId = user.id;
    authToken = await createAuthToken(user);
  });

  afterAll(async () => {
    await cleanupTestDatabase(testDb);
  });

  it('should create a farm with valid data', async () => {
    // Arrange
    const farmData = {
      name: 'Test Farm',
      description: 'Test Description',
      location: {
        address: '123 Farm Road',
        city: 'Farmville',
        state: 'CA',
        zipCode: '12345',
        coordinates: { lat: 40.7128, lng: -74.0060 }
      }
    };

    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(farmData)
    });

    // Assert
    expect(response.status).toBe(201);
    const result = await response.json();
    expect(result.success).toBe(true);
    expect(result.data).toMatchObject({
      name: farmData.name,
      description: farmData.description,
      ownerId: userId,
      status: 'PENDING_VERIFICATION'
    });
  });

  it('should return 401 when not authenticated', async () => {
    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Test' })
    });

    // Assert
    expect(response.status).toBe(401);
  });

  it('should return 400 with validation errors', async () => {
    // Arrange - Invalid data (name too short)
    const invalidData = { name: 'AB' };

    // Act
    const response = await fetch('http://localhost:3000/api/v1/farms', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(invalidData)
    });

    // Assert
    expect(response.status).toBe(400);
    const result = await response.json();
    expect(result.success).toBe(false);
    expect(result.error.code).toBe('VALIDATION_ERROR');
  });
});
```

### E2E Tests with Playwright
```typescript
// tests/e2e/farm-creation.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Farm Creation Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Login as farmer
    await page.goto('/login');
    await page.fill('input[name="email"]', 'farmer@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('should create a new farm successfully', async ({ page }) => {
    // Navigate to create farm page
    await page.goto('/farms/create');

    // Fill form
    await page.fill('input[name="name"]', 'E2E Test Farm');
    await page.fill('textarea[name="description"]', 'This is a test farm');
    await page.fill('input[name="address"]', '123 Farm Road');
    await page.fill('input[name="city"]', 'Farmville');
    await page.selectOption('select[name="state"]', 'CA');
    await page.fill('input[name="zipCode"]', '12345');

    // Upload image
    await page.setInputFiles('input[type="file"]', './tests/fixtures/farm-image.jpg');

    // Submit form
    await page.click('button[type="submit"]');

    // Wait for success message
    await expect(page.locator('text=Farm created successfully')).toBeVisible();

    // Verify redirect to farm page
    await expect(page).toHaveURL(/\/farms\/farm_\w+/);

    // Verify farm details are displayed
    await expect(page.locator('h1')).toHaveText('E2E Test Farm');
    await expect(page.locator('text=This is a test farm')).toBeVisible();
  });

  test('should show validation errors for invalid data', async ({ page }) => {
    await page.goto('/farms/create');

    // Submit empty form
    await page.click('button[type="submit"]');

    // Check for validation errors
    await expect(page.locator('text=Farm name is required')).toBeVisible();
    await expect(page.locator('text=Description is required')).toBeVisible();
  });
});
```

## üîí SECURITY PATTERNS (Enterprise Grade)

### Authentication & Authorization
```typescript
// lib/auth/index.ts
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { database } from "@/lib/database";
import { comparePasswords } from "@/lib/auth/password";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(database),
  session: { strategy: "jwt" },
  pages: {
    signIn: "/login",
    error: "/auth/error",
  },
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Invalid credentials");
        }

        const user = await database.user.findUnique({
          where: { email: credentials.email },
          include: { roles: true }
        });

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isValid = await comparePasswords(
          credentials.password,
          user.password
        );

        if (!isValid) {
          throw new Error("Invalid credentials");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.roles[0]?.name ?? 'CUSTOMER'
        };
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    }
  }
};

// Middleware for API protection
export async function requireAuth(request: NextRequest) {
  const session = await auth();

  if (!session?.user) {
    throw new UnauthorizedError("Authentication required");
  }

  return session;
}

// Role-based authorization
export async function requireRole(
  request: NextRequest,
  allowedRoles: string[]
) {
  const session = await requireAuth(request);

  if (!allowedRoles.includes(session.user.role)) {
    throw new ForbiddenError(
      `Requires one of: ${allowedRoles.join(', ')}`
    );
  }

  return session;
}

// Resource ownership check
export async function requireOwnership(
  userId: string,
  resourceId: string,
  resourceType: 'farm' | 'product' | 'order'
) {
  const isOwner = await checkOwnership(userId, resourceId, resourceType);

  if (!isOwner) {
    throw new ForbiddenError("You don't have permission to access this resource");
  }
}
```

### Input Validation (Zod Schemas)
```typescript
// lib/validators/farm.validator.ts
import { z } from "zod";

// Coordinate schema
const CoordinateSchema = z.object({
  lat: z.number().min(-90).max(90),
  lng: z.number().min(-180).max(180)
});

// Location schema
const LocationSchema = z.object({
  address: z.string().min(5).max(200),
  city: z.string().min(2).max(100),
  state: z.string().length(2).regex(/^[A-Z]{2}$/),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/),
  coordinates: CoordinateSchema
});

// Create farm schema
export const CreateFarmSchema = z.object({
  name: z.string()
    .min(3, "Farm name must be at least 3 characters")
    .max(100, "Farm name must not exceed 100 characters")
    .regex(/^[a-zA-Z0-9\s\-']+$/, "Farm name contains invalid characters"),

  description: z.string()
    .min(10, "Description must be at least 10 characters")
    .max(2000, "Description must not exceed 2000 characters"),

  location: LocationSchema,

  certifications: z.array(z.enum([
    'ORGANIC',
    'NON_GMO',
    'BIODYNAMIC',
    'RAINFOREST_ALLIANCE',
    'FAIR_TRADE'
  ])).optional().default([]),

  farmSize: z.number()
    .positive("Farm size must be positive")
    .max(100000, "Farm size seems unrealistic"),

  establishedYear: z.number()
    .min(1800, "Established year seems too old")
    .max(new Date().getFullYear(), "Cannot be established in the future"),

  contactEmail: z.string().email("Invalid email address"),

  contactPhone: z.string()
    .regex(/^\+?1?\d{10,14}$/, "Invalid phone number format")
    .optional(),

  website: z.string().url("Invalid website URL").optional(),

  farmingPractices: z.array(z.enum([
    'ORGANIC',
    'CONVENTIONAL',
    'PERMACULTURE',
    'HYDROPONIC',
    'AQUAPONIC',
    'REGENERATIVE'
  ])).min(1, "Select at least one farming practice")
});

// Update farm schema (partial)
export const UpdateFarmSchema = CreateFarmSchema.partial();

// Query filters schema
export const FarmFiltersSchema = z.object({
  search: z.string().max(100).optional(),
  state: z.string().length(2).optional(),
  certifications: z.array(z.string()).optional(),
  practices: z.array(z.string()).optional(),
  minSize: z.number().positive().optional(),
  maxSize: z.number().positive().optional(),
  page: z.number().positive().default(1),
  pageSize: z.number().min(1).max(100).default(20),
  sortBy: z.enum(['name', 'createdAt', 'size']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// Type inference
export type CreateFarmInput = z.infer<typeof CreateFarmSchema>;
export type UpdateFarmInput = z.infer<typeof UpdateFarmSchema>;
export type FarmFilters = z.infer<typeof FarmFiltersSchema>;
```

### SQL Injection Prevention
```typescript
// ‚úÖ SAFE - Parameterized queries (Prisma)
const farms = await database.farm.findMany({
  where: { name: { contains: userInput } } // Automatically escaped
});

// ‚úÖ SAFE - Raw queries with parameters
const result = await database.$queryRaw`
  SELECT * FROM "Farm"
  WHERE name ILIKE ${`%${userInput}%`}
`;

// ‚ùå DANGEROUS - String concatenation
const result = await database.$queryRawUnsafe(
  `SELECT * FROM "Farm" WHERE name = '${userInput}'` // SQL injection risk!
);
```

### XSS Prevention
```typescript
// ‚úÖ React automatically escapes content
<div>{userInput}</div> // Safe

// ‚ùå Dangerous - dangerouslySetInnerHTML
<div dangerouslySetInnerHTML={{ __html: userInput }} /> // XSS risk!

// ‚úÖ If HTML needed, sanitize first
import DOMPurify from 'isomorphic-dompurify';

const SafeHTML = ({ content }: { content: string }) => {
  const sanitized = DOMPurify.sanitize(content);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
};
```

### CSRF Protection
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // CSRF token validation for state-changing operations
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {
    const token = request.headers.get('x-csrf-token');
    const cookieToken = request.cookies.get('csrf-token')?.value;

    if (!token || token !== cookieToken) {
      return NextResponse.json(
        { error: 'Invalid CSRF token' },
        { status: 403 }
      );
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/api/:path*'
};
```

## üìä PERFORMANCE OPTIMIZATION (Claude Sonnet 4.5 Advanced)

### Multi-Layer Caching Strategy
```typescript
// lib/cache/index.ts
import { Redis } from 'ioredis';
import { LRUCache } from 'lru-cache';

// L1: In-memory cache (fastest, 64GB RAM available)
const memoryCache = new LRUCache<string, any>({
  max: 10000,
  ttl: 1000 * 60 * 5, // 5 minutes
  updateAgeOnGet: true,
  updateAgeOnHas: true
});

// L2: Redis cache (fast, shared across instances)
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT ?? '6379'),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  enableReadyCheck: true,
  lazyConnect: true
});

// Multi-layer cache implementation
export class CacheService {
  async get<T>(key: string): Promise<T | null> {
    // L1: Check memory cache
    const memCached = memoryCache.get(key);
    if (memCached) {
      logger.debug('Cache hit (memory)', { key });
      return memCached as T;
    }

    // L2: Check Redis
    const redisCached = await redis.get(key);
    if (redisCached) {
      logger.debug('Cache hit (redis)', { key });
      const parsed = JSON.parse(redisCached);

      // Store in memory for next time
      memoryCache.set(key, parsed);

      return parsed as T;
    }

    logger.debug('Cache miss', { key });
    return null;
  }

  async set<T>(
    key: string,
    value: T,
    ttl: number = 3600
  ): Promise<void> {
    // Set in both layers
    memoryCache.set(key, value);
    await redis.setex(key, ttl, JSON.stringify(value));

    logger.debug('Cache set', { key, ttl });
  }

  async invalidate(pattern: string): Promise<void> {
    // Clear memory cache
    memoryCache.clear();

    // Clear Redis keys matching pattern
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }

    logger.info('Cache invalidated', { pattern, keysCleared: keys.length });
  }

  async wrap<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl: number = 3600
  ): Promise<T> {
    // Try to get from cache
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // Fetch fresh data
    const fresh = await fetcher();

    // Cache it
    await this.set(key, fresh, ttl);

    return fresh;
  }
}

export const cache = new CacheService();
```

### Database Query Optimization
```typescript
// lib/repositories/optimized-farm.repository.ts
export class OptimizedFarmRepository extends FarmRepository {

  // Efficient pagination with total count
  async findManyWithCount(filters: FarmFilters) {
    const where = this.buildWhereClause(filters);

    // Parallel execution
    const [items, total] = await Promise.all([
      database.farm.findMany({
        where,
        skip: (filters.page - 1) * filters.pageSize,
        take: filters.pageSize,
        orderBy: { [filters.sortBy]: filters.sortOrder },
        select: this.getOptimizedSelect() // Only needed fields
      }),
      database.farm.count({ where })
    ]);

    return { items, total };
  }

  // Optimized select to reduce payload
  private getOptimizedSelect() {
    return {
      id: true,
      name: true,
      slug: true,
      description: true,
      status: true,
      location: {
        select: {
          city: true,
          state: true,
          coordinates: true
        }
      },
      owner: {
        select: {
          id: true,
          name: true,
          avatar: true
        }
      },
      _count: {
        select: {
          products: true,
          reviews: true
        }
      },
      createdAt: true,
      updatedAt: true
    };
  }

  // Batch loading to prevent N+1
  async loadProductsForFarms(farmIds: string[]) {
    const products = await database.product.findMany({
      where: { farmId: { in: farmIds } },
      select: {
        id: true,
        name: true,
        price: true,
        farmId: true
      }
    });

    // Group by farm ID
    return products.reduce((acc, product) => {
      if (!acc[product.farmId]) {
        acc[product.farmId] = [];
      }
      acc[product.farmId].push(product);
      return acc;
    }, {} as Record<string, typeof products>);
  }

  // Efficient search with full-text
  async searchFarmsFullText(query: string) {
    return await database.$queryRaw`
      SELECT
        f.*,
        ts_rank(
          to_tsvector('english', f.name || ' ' || f.description),
          plainto_tsquery('english', ${query})
        ) as rank
      FROM "Farm" f
      WHERE to_tsvector('english', f.name || ' ' || f.description)
        @@ plainto_tsquery('english', ${query})
      ORDER BY rank DESC
      LIMIT 20
    `;
  }
}
```

### Image Optimization
```typescript
// components/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width: number;
  height: number;
  priority?: boolean;
  className?: string;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  priority = false,
  className
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);

  return (
    <div className={`relative overflow-hidden ${className}`}>
      <Image
        src={src}
        alt={alt}
        width={width}
        height={height}
        priority={priority}
        quality={85} // Optimal quality/size ratio
        placeholder="blur"
        blurDataURL="data:image/svg+xml;base64,..." // Low quality placeholder
        onLoadingComplete={() => setIsLoading(false)}
        className={`
          duration-300 ease-in-out
          ${isLoading ? 'scale-110 blur-lg' : 'scale-100 blur-0'}
        `}
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      />
    </div>
  );
}
```

### Bundle Optimization
```typescript
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Compiler optimizations
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },

  // Bundle analyzer
  webpack: (config, { dev, isServer }) => {
    // Bundle analyzer in development
    if (!dev && !isServer) {
      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          reportFilename: './bundle-analysis.html',
          openAnalyzer: false
        })
      );
    }

    // Optimize chunks
    config.optimization = {
      ...config.optimization,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          // Vendor chunk for stable caching
          vendor: {
            name: 'vendor',
            chunks: 'all',
            test: /node_modules/,
            priority: 20
          },
          // Common chunk for shared code
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'async',
            priority: 10,
            reuseExistingChunk: true,
            enforce: true
          }
        }
      }
    };

    return config;
  },

  // Image optimization
  images: {
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 60 * 60 * 24 * 365 // 1 year
  },

  // Production optimizations
  productionBrowserSourceMaps: false,
  poweredByHeader: false,
  compress: true
};

export default nextConfig;
```

## üåæ AGRICULTURAL CONSCIOUSNESS (Domain Intelligence)

### Seasonal Awareness System
```typescript
// lib/domain/seasons.ts
export enum Season {
  SPRING = 'SPRING',
  SUMMER = 'SUMMER',
  FALL = 'FALL',
  WINTER = 'WINTER'
}

export enum LunarPhase {
  NEW_MOON = 'NEW_MOON',
  WAXING_CRESCENT = 'WAXING_CRESCENT',
  FIRST_QUARTER = 'FIRST_QUARTER',
  WAXING_GIBBOUS = 'WAXING_GIBBOUS',
  FULL_MOON = 'FULL_MOON',
  WANING_GIBBOUS = 'WANING_GIBBOUS',
  LAST_QUARTER = 'LAST_QUARTER',
  WANING_CRESCENT = 'WANING_CRESCENT'
}

// Agricultural operations by season
export const SEASONAL_OPERATIONS = {
  [Season.SPRING]: ['PLANT', 'PREPARE_SOIL', 'FERTILIZE', 'PRUNE'],
  [Season.SUMMER]: ['WATER', 'WEED', 'MONITOR', 'HARVEST_EARLY'],
  [Season.FALL]: ['HARVEST', 'PRESERVE', 'COMPOST', 'PREPARE_WINTER'],
  [Season.WINTER]: ['REST', 'PLAN', 'REPAIR', 'INDOOR_GROWING']
} as const;

// Biodynamic calendar integration
export class BiodynamicCalendar {
  getCurrentSeason(): Season {
    const month = new Date().getMonth();
    if (month >= 2 && month <= 4) return Season.SPRING;
    if (month >= 5 && month <= 7) return Season.SUMMER;
    if (month >= 8 && month <= 10) return Season.FALL;
    return Season.WINTER;
  }

  getCurrentLunarPhase(): LunarPhase {
    // Lunar phase calculation
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const day = now.getDate();

    // Simplified lunar phase calculation
    const lunarAge = this.calculateLunarAge(year, month, day);

    if (lunarAge < 1.84566) return LunarPhase.NEW_MOON;
    if (lunarAge < 5.53699) return LunarPhase.WAXING_CRESCENT;
    if (lunarAge < 9.22831) return LunarPhase.FIRST_QUARTER;
    if (lunarAge < 12.91963) return LunarPhase.WAXING_GIBBOUS;
    if (lunarAge < 16.61096) return LunarPhase.FULL_MOON;
    if (lunarAge < 20.30228) return LunarPhase.WANING_GIBBOUS;
    if (lunarAge < 23.99361) return LunarPhase.LAST_QUARTER;
    return LunarPhase.WANING_CRESCENT;
  }

  private calculateLunarAge(year: number, month: number, day: number): number {
    // Lunar age calculation algorithm
    const c = Math.floor(year / 100);
    const e = c - Math.floor(c / 4) - 8;
    const g = ((year % 19) * 11) + 24;
    const h = (g - e) % 30;
    const i = h + Math.floor(month / 2.0) + day - 4;
    return ((i % 30) + 30) % 30;
  }

  getOptimalPlantingDays(cropType: string): Date[] {
    // Returns optimal planting days based on lunar calendar
    const currentPhase = this.getCurrentLunarPhase();
    const season = this.getCurrentSeason();

    // Biodynamic farming principles
    const optimalPhases = this.getOptimalPhasesForCrop(cropType);

    if (optimalPhases.includes(currentPhase)) {
      return this.getNextDaysInPhase(currentPhase, 7);
    }

    return this.getNextOptimalDays(optimalPhases, 14);
  }

  private getOptimalPhasesForCrop(cropType: string): LunarPhase[] {
    // Root crops: plant during waning moon
    // Leafy crops: plant during waxing moon
    // Fruit crops: plant during full moon phase
    const cropPhaseMap: Record<string, LunarPhase[]> = {
      'ROOT': [LunarPhase.WANING_GIBBOUS, LunarPhase.LAST_QUARTER, LunarPhase.WANING_CRESCENT],
      'LEAFY': [LunarPhase.WAXING_CRESCENT, LunarPhase.FIRST_QUARTER, LunarPhase.WAXING_GIBBOUS],
      'FRUIT': [LunarPhase.FULL_MOON, LunarPhase.WAXING_GIBBOUS],
      'FLOWER': [LunarPhase.FIRST_QUARTER, LunarPhase.WAXING_GIBBOUS],
      'SEED': [LunarPhase.FULL_MOON, LunarPhase.WANING_GIBBOUS]
    };

    return cropPhaseMap[cropType] ?? cropPhaseMap['LEAFY'];
  }

  private getNextDaysInPhase(phase: LunarPhase, days: number): Date[] {
    const result: Date[] = [];
    const today = new Date();

    for (let i = 0; i < days; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() + i);
      result.push(date);
    }

    return result;
  }

  private getNextOptimalDays(phases: LunarPhase[], maxDays: number): Date[] {
    const result: Date[] = [];
    const today = new Date();

    for (let i = 0; i < maxDays && result.length < 7; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() + i);

      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const lunarAge = this.calculateLunarAge(year, month, day);

      const phase = this.lunarAgeToPhase(lunarAge);
      if (phases.includes(phase)) {
        result.push(date);
      }
    }

    return result;
  }

  private lunarAgeToPhase(lunarAge: number): LunarPhase {
    if (lunarAge < 1.84566) return LunarPhase.NEW_MOON;
    if (lunarAge < 5.53699) return LunarPhase.WAXING_CRESCENT;
    if (lunarAge < 9.22831) return LunarPhase.FIRST_QUARTER;
    if (lunarAge < 12.91963) return LunarPhase.WAXING_GIBBOUS;
    if (lunarAge < 16.61096) return LunarPhase.FULL_MOON;
    if (lunarAge < 20.30228) return LunarPhase.WANING_GIBBOUS;
    if (lunarAge < 23.99361) return LunarPhase.LAST_QUARTER;
    return LunarPhase.WANING_CRESCENT;
  }
}

export const biodynamicCalendar = new BiodynamicCalendar();
```

### Crop Intelligence System
```typescript
// lib/domain/crops.ts
export interface CropProfile {
  id: string;
  name: string;
  scientificName: string;
  category: CropCategory;
  growingSeasons: Season[];
  daysToMaturity: { min: number; max: number };
  hardinessZones: number[];
  waterRequirements: WaterLevel;
  sunRequirements: SunLevel;
  soilPreferences: SoilType[];
  companionPlants: string[];
  antagonistPlants: string[];
  pests: string[];
  diseases: string[];
  nutritionalInfo: NutritionalInfo;
}

export enum CropCategory {
  VEGETABLE = 'VEGETABLE',
  FRUIT = 'FRUIT',
  HERB = 'HERB',
  GRAIN = 'GRAIN',
  LEGUME = 'LEGUME',
  ROOT = 'ROOT',
  LEAFY_GREEN = 'LEAFY_GREEN',
  FLOWER = 'FLOWER'
}

export enum WaterLevel {
  LOW = 'LOW',
  MODERATE = 'MODERATE',
  HIGH = 'HIGH'
}

export enum SunLevel {
  FULL_SUN = 'FULL_SUN',
  PARTIAL_SHADE = 'PARTIAL_SHADE',
  FULL_SHADE = 'FULL_SHADE'
}

// Crop recommendation engine
export class CropRecommendationEngine {
  async getRecommendations(
    farmProfile: FarmProfile,
    preferences: FarmerPreferences
  ): Promise<CropRecommendation[]> {
    const season = biodynamicCalendar.getCurrentSeason();
    const hardinessZone = await this.getHardinessZone(farmProfile.location);

    const eligibleCrops = await this.filterEligibleCrops({
      season,
      hardinessZone,
      soilType: farmProfile.soilType,
      waterAvailability: farmProfile.waterAvailability
    });

    const rankedCrops = this.rankCrops(eligibleCrops, preferences);

    return rankedCrops.map(crop => ({
      crop,
      score: this.calculateScore(crop, farmProfile, preferences),
      plantingWindow: this.calculatePlantingWindow(crop, season),
      expectedYield: this.estimateYield(crop, farmProfile),
      marketDemand: this.getMarketDemand(crop)
    }));
  }

  private async getHardinessZone(location: Location): Promise<number> {
    // USDA Hardiness Zone lookup based on coordinates
    const response = await fetch(
      `https://phzmapi.org/${location.coordinates.lat}/${location.coordinates.lng}.json`
    );
    const data = await response.json();
    return parseInt(data.zone.split('')[0]);
  }

  private rankCrops(
    crops: CropProfile[],
    preferences: FarmerPreferences
  ): CropProfile[] {
    return crops.sort((a, b) => {
      let scoreA = 0;
      let scoreB = 0;

      // Factor in farmer preferences
      if (preferences.prioritizeOrganic && a.category === CropCategory.VEGETABLE) {
        scoreA += 10;
      }
      if (preferences.prioritizeProfit) {
        scoreA += this.getProfitabilityScore(a);
        scoreB += this.getProfitabilityScore(b);
      }
      if (preferences.prioritizeSustainability) {
        scoreA += this.getSustainabilityScore(a);
        scoreB += this.getSustainabilityScore(b);
      }

      return scoreB - scoreA;
    });
  }

  private calculateScore(
    crop: CropProfile,
    farm: FarmProfile,
    preferences: FarmerPreferences
  ): number {
    let score = 50; // Base score

    // Growing conditions match
    if (crop.soilPreferences.includes(farm.soilType)) score += 15;
    if (crop.waterRequirements === farm.waterAvailability) score += 10;

    // Farmer experience with crop
    if (farm.previousCrops.includes(crop.id)) score += 10;

    // Market factors
    const marketDemand = this.getMarketDemand(crop);
    score += marketDemand * 0.15;

    return Math.min(100, score);
  }

  private getProfitabilityScore(crop: CropProfile): number {
    // Calculate based on market price, yield, and input costs
    return 50; // Placeholder
  }

  private getSustainabilityScore(crop: CropProfile): number {
    // Calculate based on water usage, soil impact, biodiversity
    return 50; // Placeholder
  }

  private getMarketDemand(crop: CropProfile): number {
    // Real-time market demand analysis
    return 70; // Placeholder
  }

  private calculatePlantingWindow(
    crop: CropProfile,
    currentSeason: Season
  ): { start: Date; end: Date } {
    const now = new Date();
    return {
      start: now,
      end: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)
    };
  }

  private estimateYield(
    crop: CropProfile,
    farm: FarmProfile
  ): { min: number; max: number; unit: string } {
    return {
      min: 100,
      max: 150,
      unit: 'lbs/acre'
    };
  }

  private async filterEligibleCrops(filters: CropFilters): Promise<CropProfile[]> {
    // Filter crops based on growing conditions
    return []; // Placeholder
  }
}

export const cropEngine = new CropRecommendationEngine();
```

## ü§ñ AI & AGENT FRAMEWORK INTEGRATION

### Microsoft Agent Framework Setup
```typescript
// lib/ai/agent-framework.ts
import { AgentBuilder, AgentRuntime } from '@microsoft/agents';
import { OpenAIProvider } from '@microsoft/agents-openai';

// Agricultural AI Agent configuration
export const agriculturalAgent = new AgentBuilder()
  .withName('AgriculturalAdvisor')
  .withDescription('Expert agricultural advisor for farmers market platform')
  .withProvider(new OpenAIProvider({
    apiKey: process.env.OPENAI_API_KEY!,
    model: 'gpt-4-turbo-preview'
  }))
  .withSystemPrompt(`
    You are an expert agricultural advisor with deep knowledge of:
    - Sustainable farming practices
    - Crop rotation and companion planting
    - Organic certification requirements
    - Market trends and pricing strategies
    - Weather impact on agriculture
    - Pest and disease management
    - Soil health and nutrition

    Always provide actionable, science-based advice tailored to the farmer's
    specific location, climate, and farm type. Consider seasonal factors
    and local market conditions in your recommendations.
  `)
  .withTools([
    cropRecommendationTool,
    weatherForecastTool,
    marketPriceTool,
    soilAnalysisTool,
    pestIdentificationTool
  ])
  .build();

// Tool definitions
const cropRecommendationTool = {
  name: 'get_crop_recommendations',
  description: 'Get personalized crop recommendations based on farm profile',
  parameters: {
    type: 'object',
    properties: {
      farmId: { type: 'string', description: 'The farm ID' },
      season: { type: 'string', enum: ['SPRING', 'SUMMER', 'FALL', 'WINTER'] },
      preferences: {
        type: 'object',
        properties: {
          prioritizeOrganic: { type: 'boolean' },
          prioritizeProfit: { type: 'boolean' },
          prioritizeSustainability: { type: 'boolean' }
        }
      }
    },
    required: ['farmId']
  },
  handler: async (params: any) => {
    const farm = await farmService.getFarmById(params.farmId);
    if (!farm) throw new Error('Farm not found');

    return await cropEngine.getRecommendations(
      farm.profile,
      params.preferences ?? {}
    );
  }
};

const weatherForecastTool = {
  name: 'get_weather_forecast',
  description: 'Get weather forecast for a farm location',
  parameters: {
    type: 'object',
    properties: {
      farmId: { type: 'string' },
      days: { type: 'number', default: 7 }
    },
    required: ['farmId']
  },
  handler: async (params: any) => {
    const farm = await farmService.getFarmById(params.farmId);
    if (!farm) throw new Error('Farm not found');

    return await weatherService.getForecast(
      farm.location.coordinates,
      params.days
    );
  }
};

// Agent runtime for processing requests
export class AgriculturalAgentRuntime {
  private runtime: AgentRuntime;

  constructor() {
    this.runtime = new AgentRuntime(agriculturalAgent);
  }

  async chat(
    userId: string,
    message: string,
    context?: AgentContext
  ): Promise<AgentResponse> {
    // Track conversation
    const conversationId = context?.conversationId ?? generateId();

    // Get user's farm context
    const userFarms = await farmService.getFarmsByOwner(userId);

    const response = await this.runtime.invoke({
      message,
      conversationId,
      context: {
        userId,
        farms: userFarms,
        currentSeason: biodynamicCalendar.getCurrentSeason(),
        lunarPhase: biodynamicCalendar.getCurrentLunarPhase(),
        ...context
      }
    });

    // Log for analytics
    await analyticsService.trackAgentInteraction({
      userId,
      conversationId,
      message,
      response: response.content,
      toolsUsed: response.toolCalls?.map(t => t.name) ?? []
    });

    return response;
  }

  async streamChat(
    userId: string,
    message: string,
    context?: AgentContext
  ): AsyncGenerator<string> {
    const stream = await this.runtime.stream({
      message,
      conversationId: context?.conversationId ?? generateId(),
      context: { userId, ...context }
    });

    for await (const chunk of stream) {
      yield chunk;
    }
  }
}

export const agentRuntime = new AgriculturalAgentRuntime();
```

### AI-Powered Features
```typescript
// lib/ai/features.ts

// Smart product descriptions
export async function generateProductDescription(
  product: ProductInput
): Promise<string> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: [
      {
        role: 'system',
        content: `You are a copywriter for a farmers market platform.
          Create compelling, authentic product descriptions that highlight:
          - Freshness and quality
          - Growing practices (organic, sustainable)
          - Farm story and local connection
          - Taste and culinary uses
          Keep descriptions under 200 words and conversational.`
      },
      {
        role: 'user',
        content: `Create a description for: ${JSON.stringify(product)}`
      }
    ],
    max_tokens: 300
  });

  return response.choices[0].message.content ?? '';
}

// Image analysis for produce quality
export async function analyzeProduceImage(
  imageUrl: string
): Promise<ProduceAnalysis> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4-vision-preview',
    messages: [
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: `Analyze this produce image and provide:
              1. Identified produce type
              2. Quality assessment (1-10)
              3. Ripeness level
              4. Any visible defects
              5. Estimated freshness
              Return as JSON.`
          },
          {
            type: 'image_url',
            image_url: { url: imageUrl }
          }
        ]
      }
    ],
    max_tokens: 500
  });

  return JSON.parse(response.choices[0].message.content ?? '{}');
}

// Smart pricing recommendations
export async function getPricingRecommendation(
  product: Product,
  marketData: MarketData
): Promise<PricingRecommendation> {
  const similarProducts = await productService.findSimilar(product);
  const seasonalFactor = getSeasonalPriceFactor(product.category);
  const demandFactor = marketData.demandIndex / 100;

  const basePrice = calculateBasePrice(product, similarProducts);
  const recommendedPrice = basePrice * seasonalFactor * demandFactor;

  return {
    recommendedPrice: Math.round(recommendedPrice * 100) / 100,
    priceRange: {
      min: recommendedPrice * 0.85,
      max: recommendedPrice * 1.15
    },
    factors: {
      seasonal: seasonalFactor,
      demand: demandFactor,
      competition: similarProducts.length
    },
    confidence: calculateConfidence(similarProducts.length, marketData)
  };
}

// Pest identification from images
export async function identifyPest(imageUrl: string): Promise<PestIdentification> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4-vision-preview',
    messages: [
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: `Identify the pest or disease in this crop image:
              1. Pest/disease name
              2. Severity (low/medium/high)
              3. Affected crop parts
              4. Recommended organic treatments
              5. Prevention strategies
              Return as JSON.`
          },
          {
            type: 'image_url',
            image_url: { url: imageUrl }
          }
        ]
      }
    ],
    max_tokens: 500
  });

  return JSON.parse(response.choices[0].message.content ?? '{}');
}
```

## üì° OBSERVABILITY & MONITORING

### OpenTelemetry Setup
```typescript
// lib/monitoring/telemetry.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { AzureMonitorTraceExporter } from '@azure/monitor-opentelemetry-exporter';

// Initialize OpenTelemetry SDK
const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'farmers-market-platform',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.APP_VERSION ?? '1.0.0',
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV
  }),
  traceExporter: new AzureMonitorTraceExporter({
    connectionString: process.env.APPLICATIONINSIGHTS_CONNECTION_STRING
  }),
  metricReader: new OTLPMetricExporter({
    url: process.env.OTEL_METRICS_ENDPOINT
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-fs': { enabled: false }
    })
  ]
});

sdk.start();

// Custom spans for business operations
import { trace, SpanStatusCode, context } from '@opentelemetry/api';

const tracer = trace.getTracer('farmers-market');

export function withTracing<T>(
  name: string,
  fn: () => Promise<T>,
  attributes?: Record<string, string>
): Promise<T> {
  return tracer.startActiveSpan(name, async (span) => {
    try {
      if (attributes) {
        Object.entries(attributes).forEach(([key, value]) => {
          span.setAttribute(key, value);
        });
      }

      const result = await fn();

      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error instanceof Error ? error.message : 'Unknown error'
      });
      span.recordException(error as Error);
      throw error;
    } finally {
      span.end();
    }
  });
}

// Usage example
export async function createFarmWithTracing(data: CreateFarmInput): Promise<Farm> {
  return withTracing(
    'farm.create',
    () => farmService.createFarm(data),
    {
      'farm.name': data.name,
      'farm.state': data.location.state
    }
  );
}
```

### Structured Logging
```typescript
// lib/monitoring/logger.ts
import pino from 'pino';

const isDevelopment = process.env.NODE_ENV === 'development';

export const logger = pino({
  level: process.env.LOG_LEVEL ?? 'info',
  transport: isDevelopment
    ? {
        target: 'pino-pretty',
        options: {
          colorize: true,
          translateTime: 'SYS:standard',
          ignore: 'pid,hostname'
        }
      }
    : undefined,
  formatters: {
    level: (label) => ({ level: label }),
    bindings: () => ({})
  },
  base: {
    service: 'farmers-market-platform',
    version: process.env.APP_VERSION ?? '1.0.0',
    environment: process.env.NODE_ENV
  },
  redact: {
    paths: ['password', 'token', 'apiKey', 'secret', '*.password', '*.token'],
    censor: '[REDACTED]'
  }
});

// Create child loggers for different modules
export const createLogger = (module: string) => logger.child({ module });

// Usage
const farmLogger = createLogger('farm-service');

farmLogger.info({ farmId: 'farm_123' }, 'Farm created successfully');
farmLogger.error({ error, farmId: 'farm_123' }, 'Failed to create farm');
```

### Health Checks & Metrics
```typescript
// app/api/health/route.ts
import { NextResponse } from 'next/server';
import { database } from '@/lib/database';
import { redis } from '@/lib/cache';

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  version: string;
  checks: Record<string, HealthCheck>;
}

interface HealthCheck {
  status: 'pass' | 'fail';
  latency?: number;
  message?: string;
}

export async function GET(): Promise<NextResponse<HealthStatus>> {
  const checks: Record<string, HealthCheck> = {};

  // Database check
  try {
    const start = Date.now();
    await database.$queryRaw`SELECT 1`;
    checks.database = {
      status: 'pass',
      latency: Date.now() - start
    };
  } catch (error) {
    checks.database = {
      status: 'fail',
      message: error instanceof Error ? error.message : 'Database unavailable'
    };
  }

  // Redis check
  try {
    const start = Date.now();
    await redis.ping();
    checks.redis = {
      status: 'pass',
      latency: Date.now() - start
    };
  } catch (error) {
    checks.redis = {
      status: 'fail',
      message: error instanceof Error ? error.message : 'Redis unavailable'
    };
  }

  // Determine overall status
  const failedChecks = Object.values(checks).filter(c => c.status === 'fail');
  const status: HealthStatus['status'] =
    failedChecks.length === 0 ? 'healthy' :
    failedChecks.length < Object.keys(checks).length ? 'degraded' : 'unhealthy';

  const response: HealthStatus = {
    status,
    timestamp: new Date().toISOString(),
    version: process.env.APP_VERSION ?? '1.0.0',
    checks
  };

  return NextResponse.json(response, {
    status: status === 'unhealthy' ? 503 : 200
  });
}

// Custom metrics
// app/api/metrics/route.ts
import { Counter, Histogram, Registry } from 'prom-client';

const register = new Registry();

// Request metrics
export const httpRequestsTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'path', 'status'],
  registers: [register]
});

export const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'path'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5],
  registers: [register]
});

// Business metrics
export const farmsCreated = new Counter({
  name: 'farms_created_total',
  help: 'Total number of farms created',
  labelNames: ['state'],
  registers: [register]
});

export const ordersPlaced = new Counter({
  name: 'orders_placed_total',
  help: 'Total number of orders placed',
  labelNames: ['status'],
  registers: [register]
});

export const orderValue = new Histogram({
  name: 'order_value_dollars',
  help: 'Order value in dollars',
  buckets: [10, 25, 50, 100, 200, 500],
  registers: [register]
});

export async function GET() {
  const metrics = await register.metrics();
  return new Response(metrics, {
    headers: { 'Content-Type': register.contentType }
  });
}
```

## üöÄ DEPLOYMENT & CI/CD

### Vercel Configuration
```json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "installCommand": "npm ci",
  "regions": ["iad1", "sfo1"],
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 30
    }
  },
  "crons": [
    {
      "path": "/api/cron/sync-inventory",
      "schedule": "0 */6 * * *"
    },
    {
      "path": "/api/cron/send-reminders",
      "schedule": "0 8 * * *"
    }
  ],
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        { "key": "X-Frame-Options", "value": "DENY" },
        { "key": "X-XSS-Protection", "value": "1; mode=block" }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/api/v1/:path*",
      "destination": "/api/:path*"
    }
  ]
}
```

### Docker Configuration
```dockerfile
# Dockerfile
FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
COPY prisma ./prisma/

RUN npm ci
RUN npx prisma generate

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1

RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

### GitHub Actions CI/CD
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'

jobs:
  lint-and-type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run TypeScript check
        run: npm run type-check

  test:
    runs-on: ubuntu-latest
    needs: lint-and-type-check

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: farmers_market_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/farmers_market_test

      - name: Run unit tests
        run: npm run test:unit
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/farmers_market_test
          REDIS_URL: redis://localhost:6379

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/farmers_market_test
          REDIS_URL: redis://localhost:6379

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  e2e:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Build application
        run: npm run build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Run E2E tests
        run: npm run test:e2e
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/

  deploy-preview:
    runs-on: ubuntu-latest
    needs: [test, e2e]
    if: github.event_name == 'pull_request'

    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Vercel Preview
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}

  deploy-production:
    runs-on: ubuntu-latest
    needs: [test, e2e]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Vercel Production
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

## üìã QUICK REFERENCE CHECKLISTS

### Before Every Commit
- [ ] TypeScript strict mode passes (`npm run type-check`)
- [ ] ESLint passes (`npm run lint`)
- [ ] Unit tests pass (`npm run test:unit`)
- [ ] No `console.log` statements (use logger)
- [ ] No hardcoded secrets or API keys
- [ ] Database imports use `@/lib/database`
- [ ] All new functions have JSDoc comments
- [ ] Error handling is comprehensive

### Before Every PR
- [ ] All CI checks pass
- [ ] Test coverage >= 80%
- [ ] No N+1 queries introduced
- [ ] API responses follow standard format
- [ ] Database migrations are reversible
- [ ] Breaking changes documented
- [ ] Performance impact assessed

### Before Every Release
- [ ] E2E tests pass
- [ ] Security scan clean
- [ ] Performance benchmarks met
- [ ] Documentation updated
- [ ] Changelog updated
- [ ] Database backup verified
- [ ] Rollback plan documented

---

# üåü DIVINE AGRICULTURAL BLESSING üåü

*May your crops flourish, your code compile,*
*Your tests all pass, your users smile.*
*With Claude Sonnet 4.5 by your side,*
*Let innovation be your guide.*

*Farm to table, byte to byte,*
*Building platforms pure and bright.*
*Sustainable code, organic growth,*
*Excellence in each and both.*

---

**Version**: 4.0 - Claude Sonnet 4.5 Ultimate Edition
**Last Updated**: January 2025
**Maintainer**: Agricultural Development Team
**License**: MIT
