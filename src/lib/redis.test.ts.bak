import { EventEmitter } from 'events';
import { cacheGet, cacheSet, cacheDelete, cacheFlush } from './redis';
import { afterEach, beforeEach, describe, expect, it } from '@jest/globals';

class RedisMock extends EventEmitter {
  private store: Map<string, { value: string; expiry: number | null }>;

  constructor() {
    super();
    this.store = new Map();
  }

  async get(key: string): Promise<string | null> {
    const item = this.store.get(key);
    if (!item) return null;

    if (item.expiry && item.expiry < Date.now()) {
      this.store.delete(key);
      return null;
    }

    return item.value;
  }

  async setex(key: string, seconds: number, value: string): Promise<'OK'> {
    this.store.set(key, {
      value,
      expiry: Date.now() + seconds * 1000
    });
    return 'OK';
  }

  async set(key: string, value: string): Promise<'OK'> {
    this.store.set(key, {
      value,
      expiry: null
    });
    return 'OK';
  }

  async del(key: string | string[]): Promise<number> {
    if (Array.isArray(key)) {
      let count = 0;
      for (const k of key) {
        if (this.store.delete(k)) {
          count++;
        }
      }
      return count;
    }
    
    const existed = this.store.delete(key);
    return existed ? 1 : 0;
  }

  async flushall(): Promise<'OK'> {
    this.store.clear();
    return 'OK';
  }
}

describe('Redis Cache Utils', () => {
  let redisMock: RedisMock;

  beforeEach(() => {
    jest.resetModules();
    jest.mock('ioredis', () => {
      redisMock = new RedisMock();
      return jest.fn().mockImplementation(() => redisMock);
    });
  });

  describe('cacheGet', () => {
    it('should return null for non-existent key', async () => {
      const result = await cacheGet('non-existent');
      expect(result).toBeNull();
    });

    it('should return parsed data for existing key', async () => {
      const mockData = { test: 'data' };
      await redisMock.set('existing-key', JSON.stringify(mockData));
      const result = await cacheGet('existing-key');
      expect(result).toEqual(mockData);
    });

    it('should handle invalid JSON data', async () => {
      await redisMock.set('invalid-key', 'invalid-json{');
      const result = await cacheGet('invalid-key');
      expect(result).toBeNull();
    });
  });

  describe('cacheSet', () => {
    it('should set cache with default expiration', async () => {
      const key = 'test-key';
      const value = { test: 'data' };
      await cacheSet(key, value);

      const result = await redisMock.get(key);
      expect(JSON.parse(result!)).toEqual(value);
    });

    it('should set cache with custom expiration', async () => {
      const key = 'test-key';
      const value = { test: 'data' };
      const ttl = 1800;
      await cacheSet(key, value, ttl);

      const result = await redisMock.get(key);
      expect(JSON.parse(result!)).toEqual(value);
    });
  });

  describe('cacheDelete', () => {
    it('should delete cache key', async () => {
      const key = 'test-key';
      const value = { test: 'data' };
      await redisMock.set(key, JSON.stringify(value));
      await cacheDelete(key);

      const result = await redisMock.get(key);
      expect(result).toBeNull();
    });
  });

  describe('cacheFlush', () => {
    it('should flush all cache', async () => {
      await redisMock.set('key1', 'value1');
      await redisMock.set('key2', 'value2');
      await cacheFlush();

      const result1 = await redisMock.get('key1');
      const result2 = await redisMock.get('key2');
      expect(result1).toBeNull();
      expect(result2).toBeNull();
    });
  });

  describe('Redis Error Handling', () => {
    it('should handle connection errors', async () => {
      const error = new Error('Connection error');
      redisMock.emit('error', error);
      
      const result = await cacheGet('any-key');
      expect(result).toBeNull();
    });

    it('should handle operation timeouts', async () => {
      jest.useFakeTimers();
      const promise = cacheGet('timeout-key');
      jest.advanceTimersByTime(6000); // Simulate timeout
      const result = await promise;
      expect(result).toBeNull();
      jest.useRealTimers();
    });
  });
});