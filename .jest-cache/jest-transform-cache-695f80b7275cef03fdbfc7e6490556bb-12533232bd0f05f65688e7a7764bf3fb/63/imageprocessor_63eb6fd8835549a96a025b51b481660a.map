{"file":"M:\\Repo\\Farmers Market Platform web and app\\src\\lib\\gpu\\image-processor.ts","mappings":"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","names":[],"sources":["M:\\Repo\\Farmers Market Platform web and app\\src\\lib\\gpu\\image-processor.ts"],"sourcesContent":["/**\n * GPU IMAGE PROCESSOR\n * RTX 2070 Max-Q Optimized Image Processing with fallbacks\n */\n\nlet tf: any;\nlet GPU: any;\n\ntry {\n  tf = require(\"@tensorflow/tfjs-node-gpu\");\n} catch {\n  try {\n    tf = require(\"@tensorflow/tfjs\");\n    require(\"@tensorflow/tfjs-backend-webgl\");\n  } catch {\n    tf = require(\"@tensorflow/tfjs\");\n  }\n}\n\ntry {\n  GPU = require(\"gpu.js\").GPU;\n} catch {\n  // Fallback mock GPU class for when gpu.js is not available\n  GPU = class MockGPU {\n    createKernel() {\n      // Return a serializable mock kernel object instead of a function\n      return {\n        setOutput: () => ({ setPipeline: () => ({}) }),\n        setConstants: () => ({}),\n        setPipeline: () => ({}),\n        destroy: () => {},\n        __isMock: true,\n      };\n    }\n  };\n}\n\ninterface ImageProcessingOptions {\n  width?: number;\n  height?: number;\n  quality?: number;\n  format?: \"webp\" | \"jpeg\" | \"png\";\n  optimize?: boolean;\n}\n\ninterface ProcessedImage {\n  buffer: Buffer;\n  width: number;\n  height: number;\n  format: string;\n  processingTime: number;\n}\n\nexport class GPUImageProcessor {\n  private gpu: any = null;\n  private initialized: boolean = false;\n\n  constructor() {\n    // GPU initialization moved to initialize() for serialization compatibility\n  }\n\n  private getGPU(): any {\n    if (!this.gpu) {\n      this.gpu = new GPU({\n        mode: \"gpu\", // Force GPU mode for RTX 2070 Max-Q\n      });\n    }\n    return this.gpu;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Initialize TensorFlow.js GPU backend\n      await tf.setBackend(\"tensorflow\");\n      await tf.ready();\n\n      console.log(\"üöÄ GPU Image Processor initialized\");\n      console.log(\"   Backend:\", tf.getBackend());\n      console.log(\"   CUDA enabled:\", await tf.env().getBool(\"WEBGL_VERSION\"));\n\n      this.initialized = true;\n    } catch (error) {\n      console.error(\"‚ùå GPU initialization failed:\", error);\n      throw new Error(\"Failed to initialize GPU image processor\");\n    }\n  }\n\n  /**\n   * DIVINE IMAGE RESIZE WITH GPU ACCELERATION\n   * Uses RTX 2070 Max-Q for parallel pixel processing\n   */\n  async resizeImage(\n    imageBuffer: Buffer,\n    width: number,\n    height: number\n  ): Promise<ProcessedImage> {\n    const startTime = performance.now();\n\n    try {\n      // Convert buffer to tensor\n      const imageTensor = tf.node.decodeImage(imageBuffer, 3);\n\n      // GPU-accelerated resize using bilinear interpolation\n      const resized = tf.image.resizeBilinear(\n        imageTensor,\n        [height, width],\n        true // alignCorners for better quality\n      );\n\n      // Convert back to buffer\n      const buffer = await tf.node.encodeJpeg(\n        resized,\n        \"rgb\",\n        90\n      );\n\n      // Cleanup tensors\n      imageTensor.dispose();\n      resized.dispose();\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        buffer: Buffer.from(buffer),\n        width,\n        height,\n        format: \"jpeg\",\n        processingTime,\n      };\n    } catch (error) {\n      console.error(\"GPU resize failed:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * QUANTUM BATCH IMAGE PROCESSING\n   * Process multiple images in parallel using GPU\n   */\n  async processBatch(\n    images: Buffer[],\n    options: ImageProcessingOptions = {}\n  ): Promise<ProcessedImage[]> {\n    const startTime = performance.now();\n    const {\n      width = 800,\n      height = 600,\n      quality = 85,\n      format = \"webp\",\n    } = options;\n\n    try {\n      // Process all images in parallel on GPU\n      const results = await Promise.all(\n        images.map(async (imageBuffer) => {\n          return await this.resizeImage(imageBuffer, width, height);\n        })\n      );\n\n      const totalTime = performance.now() - startTime;\n      console.log(\n        `‚úÖ Processed ${images.length} images in ${totalTime.toFixed(2)}ms`\n      );\n      console.log(\n        `   Average: ${(totalTime / images.length).toFixed(2)}ms per image`\n      );\n\n      return results;\n    } catch (error) {\n      console.error(\"Batch processing failed:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * DIVINE IMAGE ENHANCEMENT\n   * GPU-accelerated brightness, contrast, saturation adjustment\n   */\n  async enhanceImage(\n    imageBuffer: Buffer,\n    brightness: number = 1.0,\n    contrast: number = 1.0,\n    saturation: number = 1.0\n  ): Promise<ProcessedImage> {\n    const startTime = performance.now();\n\n    try {\n      const imageTensor = tf.node.decodeImage(imageBuffer, 3);\n\n      // GPU-accelerated enhancement\n      let enhanced = imageTensor;\n\n      // Brightness adjustment\n      if (brightness !== 1.0) {\n        enhanced = tf.mul(enhanced, brightness);\n      }\n\n      // Contrast adjustment\n      if (contrast !== 1.0) {\n        const mean = enhanced.mean();\n        enhanced = tf.add(tf.mul(tf.sub(enhanced, mean), contrast), mean);\n      }\n\n      // Saturation adjustment (convert to HSV, adjust S, convert back)\n      if (saturation !== 1.0) {\n        // Simplified saturation (for performance)\n        const gray = enhanced.mean(-1, true);\n        enhanced = tf.add(\n          tf.mul(enhanced, saturation),\n          tf.mul(gray, 1 - saturation)\n        );\n      }\n\n      // Clamp values to [0, 255]\n      enhanced = tf.clipByValue(enhanced, 0, 255);\n\n      const buffer = await tf.node.encodeJpeg(enhanced, \"rgb\", 90);\n\n      // Cleanup\n      imageTensor.dispose();\n      enhanced.dispose();\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        buffer: Buffer.from(buffer),\n        width: imageTensor.shape[1],\n        height: imageTensor.shape[0],\n        format: \"jpeg\",\n        processingTime,\n      };\n    } catch (error) {\n      console.error(\"GPU enhancement failed:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * GPU MEMORY CLEANUP\n   */\n  dispose(): void {\n    tf.disposeVariables();\n    this.initialized = false;\n    console.log(\"üßπ GPU resources cleaned up\");\n  }\n}\n\n// Singleton instance\nlet gpuProcessor: GPUImageProcessor | null = null;\n\nexport async function getGPUProcessor(): Promise<GPUImageProcessor> {\n  if (!gpuProcessor) {\n    gpuProcessor = new GPUImageProcessor();\n    await gpuProcessor.initialize();\n  }\n  return gpuProcessor;\n}\n\n/**\n * DIVINE CONVENIENCE FUNCTION\n * One-line GPU image processing\n */\nexport async function processImageGPU(\n  imageBuffer: Buffer,\n  options: ImageProcessingOptions = {}\n): Promise<ProcessedImage> {\n  const processor = await getGPUProcessor();\n  const { width = 800, height = 600 } = options;\n  return await processor.resizeImage(imageBuffer, width, height);\n}\n"],"version":3}